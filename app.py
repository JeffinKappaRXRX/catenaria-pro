import math import io import numpy as np import pandas as pd import streamlit as st from streamlit.components.v1 import html import matplotlib.pyplot as plt from matplotlib.patches import Circle, Rectangle, FancyArrowPatch from datetime import datetime from reportlab.lib.pagesizes import A4 from reportlab.lib import colors from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image as RLImage from reportlab.lib.units import mm from docx import Document from docx.shared import Inches, Pt from docx.enum.text import WD_ALIGN_PARAGRAPH # ======================= # PLOT BONITO DA CATEN√ÅRIA # ======================= def _y_at_x(df: pd.DataFrame, col: str, x_target: float) -> float: """Valor da coluna 'col' no x mais pr√≥ximo de x_target.""" idx = int(np.abs(df["x (m)"] - x_target).idxmin()) return float(df[col].iloc[idx]) def pretty_catenary_plot( df: pd.DataFrame, L: float, H_esq: float, H_dir: float, delta_solo: float, res: dict, folga_req: float | None = None, titulo: str = "V√£o" ): """ Desenha: Solo, Corda, Caten√°ria, Postes, Isoladores, Flecha meio, Flecha m√°x, Folga m√≠nima. Coloca RESUMO e LEGENDA FORA do eixo para n√£o cobrir o desenho. """ # ==== figura maior e com espa√ßo para texto/legenda fora ==== fig, ax = plt.subplots(figsize=(10, 6), dpi=160) # margem direita p/ legenda e margem superior p/ quadro-resumo fig.subplots_adjust(left=0.10, right=0.82, bottom=0.12, top=0.82) # --- curvas principais (sem cor fixa; Streamlit aplica tema) --- ax.plot(df["x (m)"], df["Solo (m)"], label="Solo", linewidth=2) ax.plot(df["x (m)"], df["Corda (m)"], label="Corda entre apoios", linewidth=2) ax.plot(df["x (m)"], df["Caten√°ria (m)"], label="Caten√°ria", linewidth=2) # --- postes --- post_w = max(0.4, 0.015*L) ground_left, ground_right = 0.0, delta_solo hL = max(0.05, H_esq - ground_left) hR = max(0.05, H_dir - ground_right) ax.add_patch(Rectangle((-post_w/2, ground_left), post_w, hL, facecolor="#8d99ae", edgecolor="black", zorder=3)) ax.add_patch(Rectangle((L-post_w/2, ground_right), post_w, hR, facecolor="#8d99ae", edgecolor="black", zorder=3)) cap = 0.9*post_w ax.plot([-cap/2, cap/2], [H_esq, H_esq], color="black", linewidth=3, zorder=4) ax.plot([L-cap/2, L+cap/2], [H_dir, H_dir], color="black", linewidth=3, zorder=4) # isoladores isol_r = max(0.08, 0.003*L) ax.add_patch(Circle((0.0, H_esq), radius=isol_r, facecolor="white", edgecolor="black", lw=1.5, zorder=5)) ax.add_patch(Circle((L, H_dir), radius=isol_r, facecolor="white", edgecolor="black", lw=1.5, zorder=5)) # helpers de r√≥tulo com offset em pontos def side_offsets(xpos: float): if xpos < 0.6*L: return (10, 8, "left") else: return (-10, 8, "right") # --- flecha no meio (‚Üï) mais discreta --- xm = L/2 y_chord_m = _y_at_x(df, "Corda (m)", xm) y_cat_m = _y_at_x(df, "Caten√°ria (m)", xm) ax.annotate("", xy=(xm, y_chord_m), xytext=(xm, y_cat_m), arrowprops=dict(arrowstyle="<->", lw=1.3, alpha=0.9)) ox, oy, ha = side_offsets(xm) ax.annotate(f"f_meio = {res['sag_meio (m)']:.2f} m", xy=(xm, (y_chord_m+y_cat_m)/2), xytext=(ox, oy), textcoords="offset points", ha=ha, va="bottom", bbox=dict(boxstyle="round,pad=0.2", fc="white", alpha=0.85)) # --- flecha m√°xima (‚Üï) --- x_fmax = float(res["x_sag_max (m)"]) y_cat_fmax = _y_at_x(df, "Caten√°ria (m)", x_fmax) y_chord_fmax = _y_at_x(df, "Corda (m)", x_fmax) ax.scatter([x_fmax], [y_cat_fmax], s=32, zorder=6, marker="o", edgecolor="black") ax.annotate("", xy=(x_fmax, y_chord_fmax), xytext=(x_fmax, y_cat_fmax), arrowprops=dict(arrowstyle="<->", lw=1.2, alpha=0.9)) ox, oy, ha = side_offsets(x_fmax) ax.annotate(f"f_max = {res['sag_max (m)']:.2f} m", xy=(x_fmax, (y_chord_fmax+y_cat_fmax)/2), xytext=(ox, oy), textcoords="offset points", ha=ha, va="bottom", bbox=dict(boxstyle="round,pad=0.2", fc="white", alpha=0.85)) # --- folga m√≠nima (‚Üï) com linha mais leve --- xclr = float(res["x_clear_min (m)"]) y_cat_clr = _y_at_x(df, "Caten√°ria (m)", xclr) y_ground_clr = _y_at_x(df, "Solo (m)", xclr) status_ok = True if folga_req is None else (res["clear_min (m)"] + 1e-6 >= folga_req) color_clr = "#16a34a" if status_ok else "#dc2626" ax.annotate("", xy=(xclr, y_cat_clr), xytext=(xclr, y_ground_clr), arrowprops=dict(arrowstyle="<->", lw=1.4, color=color_clr, alpha=0.85)) ax.scatter([xclr], [y_cat_clr], s=28, zorder=6, facecolor=color_clr, edgecolor="black") ox, oy, ha = side_offsets(xclr) ax.annotate(f"Folga m√≠n = {res['clear_min (m)']:.2f} m", xy=(xclr, (y_cat_clr+y_ground_clr)/2), xytext=(ox, oy), textcoords="offset points", ha=ha, va="bottom", color=color_clr, bbox=dict(boxstyle="round,pad=0.2", fc="white", alpha=0.90, ec=color_clr)) # --- resumo FORA da √°rea do eixo (no "cabe√ßalho" da figura) --- resumo = ( f"f_meio={res['sag_meio (m)']:.2f} m | f_max={res['sag_max (m)']:.2f} m @ x={res['x_sag_max (m)']:.1f} m\n" f"H={res['H_horizontal (N)']/1000:.3f} kN | " f"T_esq={res['T_left (N)']/1000:.3f} kN | T_dir={res['T_right (N)']/1000:.3f} kN\n" f"Folga_min={res['clear_min (m)']:.2f} m" + (f" / Req={folga_req:.2f} m ‚Äî " + ("OK" if status_ok else "ALERTA") if folga_req is not None else "") ) # fig.text usa coordenada da figura (0..1). Vai pro "topo" fora do gr√°fico. fig.text(0.10, 0.975, resumo, ha="left", va="top", fontsize=10, bbox=dict(boxstyle="round", fc="white", ec=(color_clr if folga_req is not None else "0.5"), lw=1.4, alpha=0.98)) # --- acabamento --- ax.set_xlim(-post_w, L + post_w) ax.set_xlabel("Posi√ß√£o x (m)") ax.set_ylabel("Altura (m)") ax.set_title(titulo, pad=14) ax.grid(True, linestyle="--", linewidth=0.5, alpha=0.5) # legenda FORA do eixo (lado direito) ax.legend(loc="upper left", bbox_to_anchor=(1.005, 1.0), borderaxespad=0., framealpha=0.95) fig.tight_layout() return fig # ==== Mini-calculador de p_v (vento) ==== def _guess_deq_mm(nome_cabo: str) -> float: """Chute razo√°vel para D_eq (mm), s√≥ pra facilitar. Ajuste conforme cat√°logo.""" s = (nome_cabo or "").lower() if "bt multiplexado" in s or "quadriplex" in s or "triplex" in s or "duplex" in s: return 45.0 # largura t√≠pica de feixe ABC (edite se tiver a medida do teu fornecedor) if "mt coberto" in s: return 25.0 # cabo coberto 15/25 kV ~18‚Äì30 mm if "caa/ra" in s or "acsr" in s: return 20.0 # ACSR ~10‚Äì25 mm (depende da bitola) return 20.0 def vento_calc_expander(prefix: str, nome_cabo: str, target_key: str | None): """ Bloco UI para calcular p_v e aplicar no number_input de p_v via session_state[target_key]. - prefix: s√≥ pra diferenciar widgets entre abas ("calc_", "pre_") - nome_cabo: string que voc√™ j√° mostra no cabe√ßalho - target_key: 'calc_pv' (aba c√°lculo) ou 'pre_pv' (pr√©-projeto). Se None, s√≥ exibe o resultado. """ import streamlit as st with st.expander("üå¨Ô∏è Calcular p_v (vento)"): col1, col2 = st.columns(2) with col1: v_unit = st.radio(f"{prefix}Unidade de V", ["m/s", "km/h"], horizontal=True, key=f"{prefix}vunit") with col2: V_in = st.number_input(f"{prefix}Velocidade do vento (V)", value=35.0, step=1.0, format="%.1f", key=f"{prefix}V") V_ms = V_in if v_unit == "m/s" else V_in/3.6 Cd_default = 1.3 if ("bt multiplexado" in (nome_cabo or "").lower()) else 1.2 D_default = _guess_deq_mm(nome_cabo) col3, col4 = st.columns(2) with col3: Cd = st.number_input(f"{prefix}Coeficiente de arrasto C_d", value=float(Cd_default), step=0.05, format="%.2f", key=f"{prefix}Cd") with col4: D_mm = st.number_input(f"{prefix}D_eq (mm) ‚Äî di√¢metro/largura equivalente", value=float(D_default), step=1.0, format="%.1f", key=f"{prefix}D") q = 0.613*(V_ms**2) # N/m¬≤ Deq_m = D_mm/1000.0 # m p_v = q*Cd*Deq_m # N/m st.metric("p_v calculado", f"{p_v:.2f} N/m", help=f"q={q:.1f} N/m¬≤, C_d={Cd:.2f}, D_eq={Deq_m:.3f} m") if target_key: # Usar uma key separada para controlar a aplica√ß√£o apply_key = f"{prefix}apply_pv_flag" if st.button("‚Üß Usar este p_v no formul√°rio", key=f"{prefix}apply_pv"): st.session_state[apply_key] = float(p_v) st.success(f"Aplicado: p_v = {p_v:.2f} N/m") st.rerun() st.caption("F√≥rmula: p_v = 0,613¬∑V¬≤¬∑C_d¬∑D_eq (V em m/s; D_eq em m). Ajuste C_d/D_eq conforme cat√°logo/ensaio.") # ==== Utilidades: copiar S e calcular bobina ==== def copy_s_and_bobina_ui(S_val: float, prefix: str = ""): """ Mostra S, bot√£o 'Copiar S', e c√°lculo de quantos v√£os cabem por bobina. prefix: string para diferenciar widgets entre modos/abas. """ st.markdown("#### Utilidades de montagem") c1, c2, c3 = st.columns([1.2, 1, 1]) with c1: st.metric("Comprimento do cabo S", f"{S_val:.3f} m") # bot√£o copiar com HTML simples html(f""" <button onclick="navigator.clipboard.writeText('{S_val:.3f}'); var e=document.getElementById('ok_{prefix}'); e.innerText='Copiado!'; e.style.color='#22c55e';" style="padding:6px 10px; margin-top:6px;">üìã Copiar S</button> <span id="ok_{prefix}" style="margin-left:8px;"></span> """, height=46) with c2: bobina = st.number_input(f"{prefix}Bobina dispon√≠vel (m)", value=1000.0, min_value=1.0, step=1.0, format="%.1f") with c3: reserva = st.number_input(f"{prefix}Reserva/perdas por v√£o (m)", value=0.50, min_value=0.0, step=0.1, format="%.2f", help="Sobras de amarra√ß√£o, corte, emenda, etc.") vao_util = max(1e-9, S_val + reserva) # evita divis√£o por zero vaos_por_bobina = int(bobina // vao_util) sobra = bobina - vaos_por_bobina * vao_util st.write(f"**V√£os por bobina:** {vaos_por_bobina} | **Sobra da bobina:** {sobra:.2f} m " f"| **S + reserva/v√£o:** {vao_util:.3f} m") n_vaos = st.number_input(f"{prefix}Planejamento ‚Äî quantidade de v√£os", value=0, min_value=0, step=1) if n_vaos > 0: if vaos_por_bobina == 0: st.warning("Com os valores atuais, 0 v√£os cabem em uma bobina. Aumente a bobina ou reduza a reserva.") else: bobinas_necess = math.ceil(n_vaos / vaos_por_bobina) sobra_total = bobinas_necess * bobina - n_vaos * vao_util st.info(f"**Bobinas necess√°rias:** {bobinas_necess} | **Sobra total estimada:** {sobra_total:.2f} m") def catenary_length_from_params(L: float, a: float, xc: float) -> float: """ Calcula o comprimento S da caten√°ria usando os par√¢metros a e xc. Formula: S = a * [sinh((L-xc)/a) + sinh(xc/a)] """ import math try: left_term = math.sinh((L - xc) / a) right_term = math.sinh(xc / a) S = a * (left_term + right_term) return S except (ValueError, OverflowError): # Fallback: aproxima√ß√£o para pequenos valores return L * (1 + ((L-xc)**2 + xc**2) / (8 * a**2)) # ============================================ # ===== NBR 15992 - DIST√ÇNCIAS DE SEGURAN√áA ====== # ============================================ # --- NBR 15992 ‚Äî Tabela 12 (‚â§ 36,2 kV) | valores em METROS --- # colunas: COM = circuito de comunica√ß√£o / cabo de aterrados # BT = U ‚â§ 1,0 kV # MT = 1,0 < U ‚â§ 36,2 kV NBR15992_T12 = { "Vias exclusivas de pedestres em √°reas rurais": {"COM": 3.0, "BT": 4.5, "MT": 5.5}, "Vias exclusivas de pedestres em √°reas urbanas": {"COM": 3.0, "BT": 3.5, "MT": 5.5}, "Locais acess√≠veis ao tr√¢nsito de ve√≠culos (rural)": {"COM": 4.5, "BT": 4.5, "MT": 6.0}, "Locais acess√≠veis a m√°quinas/equip. (rural)": {"COM": 6.0, "BT": 6.0, "MT": 6.0}, "Ruas e avenidas": {"COM": 5.0, "BT": 5.5, "MT": 6.0}, "Entradas de pr√©dios/locais de uso restrito a ve√≠culos": {"COM": 4.5, "BT": 4.5, "MT": 6.0}, "Rodovias federais": {"COM": 7.0, "BT": 7.0, "MT": 7.0}, "Ferrovias n√£o eletrificadas e n√£o eletrific√°veis": {"COM": 6.0, "BT": 6.0, "MT": 9.0}, # Nota da tabela: ferrovias eletrificadas/eletrific√°veis ‚Üí 12 m para tens√µes at√© 36,2 kV "Ferrovias eletrificadas ou eletrific√°veis (at√© 36,2 kV)": {"FIXO": 12.0}, } # Tabela 13 da NBR 15992 - Dist√¢ncias m√≠nimas de seguran√ßa el√©trica (em metros) NBR15992_T13 = { # FIXOS (apenas n√∫mero) "Locais acess√≠veis apenas a pedestres": {69: 6.000, 138: 6.400, 230: 6.900, 345: 7.600, 500: 8.600}, "Locais com m√°quinas agr√≠colas < 3,5 m": {69: 6.500, 138: 6.900, 230: 7.400, 345: 8.100, 500: 9.100}, "Cultura de caf√© / m√°quinas < 5,0 m": {69: 8.000, 138: 8.400, 230: 8.900, 345: 9.600, 500: 11.000}, "Rodovias, ruas e avenidas": {69: 8.000, 138: 8.400, 230: 8.900, 345: 9.600, 500: 11.000}, "Ferrovias n√£o eletrificadas / n√£o eletrific√°veis":{69: 9.000, 138: 9.400, 230: 9.900, 345: 11.000, 500: 12.000}, "Ferrovias eletrificadas (ou previs√£o)": {69: 12.000,138: 12.400,230: 12.900,345: 13.600,500: 14.600}, "√Åguas n√£o naveg√°veis": {69: 6.000, 138: 6.400, 230: 6.900, 345: 7.600, 500: 8.600}, # H+ (depende da altura do obst√°culo informado em m) "Linhas de energia el√©trica (p√°ra-raios/RDs ‚â§ 34,5 kV)": {"H+": {69: 1.200, 138: 1.600, 230: 2.100, 345: 2.800, 500: 3.800}}, "Linhas de telecomunica√ß√µes": {"H+": {69: 1.800, 138: 2.200, 230: 2.700, 345: 3.400, 500: 4.800}}, "Suporte de linhas pertencentes √† ferrovia": {"H+": {69: 4.000, 138: 4.400, 230: 4.900, 345: 5.600, 500: 6.600}}, "Ve√≠culos rodovi√°rios/ferrovi√°rios e m√°quinas > 5 m": {"H+": {69: 3.000, 138: 3.400, 230: 3.900, 345: 4.600, 500: 5.600}}, "Muros": {"H+": {69: 6.000, 138: 6.400, 230: 6.900, 345: 7.600, 500: 8.600}}, "Instala√ß√µes transportadoras": {"H+": {69: 3.000, 138: 3.400, 230: 3.900, 345: 4.600, 500: 5.600}}, "Mata/vegeta√ß√£o adulta (topo)": {"H+": {69: 4.000, 138: 4.400, 230: 4.900, 345: 5.600, 500: 6.600}}, "√Åguas naveg√°veis": {"H+": {69: 2.000, 138: 2.400, 230: 2.900, 345: 3.600, 500: 4.600}}, } def calcular_distancia_minima_seguranca(tipo_local, tensao_kv, altura_obstaculo=None): """ Calcula a dist√¢ncia m√≠nima de seguran√ßa segundo NBR 15992 Tabela 13. Args: tipo_local (str): Tipo de local/obst√°culo da tabela tensao_kv (int): Tens√£o nominal em kV (69, 138, 230, 345, 500) altura_obstaculo (float, optional): Altura do obst√°culo em metros (para tipos H+) Returns: tuple: (distancia_minima, is_altura_dependente, descricao) """ if tipo_local not in NBR15992_T13: return None, False, "Tipo de local n√£o encontrado na tabela NBR 15992" config = NBR15992_T13[tipo_local] # Verificar se tens√£o est√° dispon√≠vel if tensao_kv not in [69, 138, 230, 345, 500]: return None, False, f"Tens√£o {tensao_kv} kV n√£o est√° na tabela NBR 15992" # Tipo H+ (altura dependente) if "H+" in config: if altura_obstaculo is None: return None, True, f"Altura do obst√°culo necess√°ria para '{tipo_local}'" distancia_base = config["H+"][tensao_kv] distancia_total = altura_obstaculo + distancia_base return distancia_total, True, f"H({altura_obstaculo:.1f}m) + {distancia_base:.1f}m = {distancia_total:.1f}m" # Tipo fixo else: distancia = config[tensao_kv] return distancia, False, f"Dist√¢ncia fixa: {distancia:.1f}m" def verificar_seguranca_eletrica(distancia_medida, tipo_local, tensao_kv, altura_obstaculo=None): """ Verifica se a dist√¢ncia medida atende aos requisitos de seguran√ßa NBR 15992. Returns: dict: {seguro: bool, distancia_minima: float, diferenca: float, tipo: str, descricao: str} """ dist_min, is_altura_dep, descricao = calcular_distancia_minima_seguranca(tipo_local, tensao_kv, altura_obstaculo) if dist_min is None: return { "seguro": None, "distancia_minima": None, "diferenca": None, "tipo": "erro", "descricao": descricao } diferenca = distancia_medida - dist_min seguro = diferenca >= 0 return { "seguro": seguro, "distancia_minima": dist_min, "diferenca": diferenca, "tipo": "altura_dependente" if is_altura_dep else "fixo", "descricao": descricao, "tensao_kv": tensao_kv, "altura_obstaculo": altura_obstaculo } # ============================================ # ===== CAT√ÅLOGO DE CABOS E FOLGAS ========== # ============================================ # Cat√°logo de cabos com pesos lineares em kg/m CABOS = { "BT Multiplexado": { "Duplex ‚Äî neutro nu": { "1x1x35+35": 0.234, # ~234 kg/km }, "Duplex ‚Äî neutro isolado": { "1x1x35+35": 0.286, # ~286 kg/km }, "Triplex ‚Äî neutro nu": { "2x1x50+50": 0.495, # ~495 kg/km }, "Triplex ‚Äî neutro isolado": { "2x1x50+50": 0.558, # ~558 kg/km }, "Quadriplex ‚Äî neutro nu": { "3x1x70+70": 0.915, # ~915 kg/km }, "Quadriplex ‚Äî neutro isolado": { "3x1x70+70": 0.988, # ~988 kg/km }, }, "MT coberto 15 kV (XLPE/HDPE)": { "35": 0.234, "50": 0.283, "70": 0.366, "95": 0.460, "120": 0.555, "150": 0.652, "185": 0.766 }, "MT coberto 25 kV (XLPE/HDPE)": { "70": 0.639, "95": 0.755, "120": 0.868, "150": 0.982, "185": 1.119 }, "Alum√≠nio XLPE/PVC (ICALi-XP)": { "35": 0.178, "50": 0.230, "70": 0.294, "95": 0.384, "120": 0.483, "150": 0.596, "185": 0.725 }, "CAA/RA (ACSR/AW)": { "4 AWG": 0.081, "2 AWG": 0.129, "1 AWG": 0.163, "1/0 AWG": 0.206, "2/0 AWG": 0.259, "3/0 AWG": 0.327, "4/0 AWG": 0.412, "336.4 MCM (Linnet 26/7)": 0.657, "336.4 MCM (Merlin 18/1)": 0.532, "336.4 MCM (Oriole 30/7)": 0.737 }, } # Classes/uso -> folga m√≠nima (m) FOLGA_CLASSES = { "Personalizado": None, "Passeio / pedestres": 5.5, "Rua urbana / local": 6.0, "Avenida / Rodovia": 7.0, "Travessia acesso veicular": 5.5, } def selector_cabo(prefix: str = ""): """Interface para sele√ß√£o de cabo do cat√°logo""" st.markdown("### üìã Sele√ß√£o de Cabo (cat√°logo)") colg1, colg2 = st.columns(2) with colg1: grupo = st.selectbox(f"Grupo", list(CABOS.keys()), key=f"{prefix}grupo") with colg2: if grupo == "BT Multiplexado": subgrupo = st.selectbox(f"Arranjo (neutro)", list(CABOS[grupo].keys()), key=f"{prefix}sub") secoes = list(CABOS[grupo][subgrupo].keys()) item = st.selectbox(f"Se√ß√£o/arranjo", secoes, key=f"{prefix}item") peso_kgpm = CABOS[grupo][subgrupo][item] nome = f"{grupo} ‚Äî {subgrupo} ‚Äî {item}" else: subgrupo = None secoes = list(CABOS[grupo].keys()) item = st.selectbox(f"Bitola / se√ß√£o", secoes, key=f"{prefix}item") peso_kgpm = CABOS[grupo][item] nome = f"{grupo} ‚Äî {item}" return nome, peso_kgpm # kg/m def folga_norma_selector(prefix: str = ""): st.markdown("### Folga m√≠nima ‚Äî NBR 15992") perfil = st.selectbox( f"{prefix}Perfil da norma", ["Distribui√ß√£o (Tabela 12 ‚Äî ‚â§ 36,2 kV)", "Extra-Alta (Tabela 13 ‚Äî ‚â• 69 kV)"], key=f"{prefix}perfil" ) # ---------- Tabela 12 (‚â§ 36,2 kV) ---------- if perfil.startswith("Distribui√ß√£o"): mapa_col = {"Circuitos de comunica√ß√£o / cabos de aterrados": "COM", "U ‚â§ 1,0 kV": "BT", "1,0 < U ‚â§ 36,2 kV": "MT"} coluna_nome = st.selectbox(f"{prefix}Faixa de tens√£o", list(mapa_col.keys()), key=f"{prefix}faixa12") col = mapa_col[coluna_nome] tipo = st.selectbox(f"{prefix}Natureza do logradouro", list(NBR15992_T12.keys()), key=f"{prefix}obs12") regra = NBR15992_T12[tipo] if "FIXO" in regra: folga_req = float(regra["FIXO"]) st.caption(f"Exigido (fixo): **{folga_req:.2f} m** (nota da norma para at√© 36,2 kV).") meta = {"perfil": "T12", "faixa": col, "tipo": tipo, "H_obst (m)": 0.0} return folga_req, meta folga_req = float(regra[col]) st.caption(f"Exigido: **{folga_req:.2f} m** ({coluna_nome}).") meta = {"perfil": "T12", "faixa": col, "tipo": tipo, "H_obst (m)": 0.0} return folga_req, meta # ---------- Tabela 13 (‚â• 69 kV) ---------- else: U = st.selectbox(f"{prefix}Tens√£o de refer√™ncia (kV)", [69, 138, 230, 345, 500], key=f"{prefix}U13") tipo = st.selectbox(f"{prefix}Natureza do obst√°culo", list(NBR15992_T13.keys()), key=f"{prefix}obs13") entry = NBR15992_T13[tipo] H_obst = 0.0 if isinstance(entry, dict) and "H+" in entry: delta = entry["H+"][U] # em m H_obst = st.number_input(f"{prefix}H (m) ‚Äî altura do obst√°culo no ponto de travessia", value=0.0, min_value=0.0, step=0.1, format="%.2f", key=f"{prefix}Hobs13") folga_req = H_obst + delta st.caption(f"Exigido: **H + {delta:.2f} m** ‚Üí com H={H_obst:.2f} m ‚áí **{folga_req:.2f} m**") else: folga_req = entry[U] st.caption(f"Exigido: **{folga_req:.2f} m** ({tipo} @ {U} kV)") meta = {"perfil": "T13", "U_kV": U, "tipo": tipo, "H_obst (m)": H_obst} return folga_req, meta def show_ok_alerta(clear_min: float, folga_req: float): """Mostra verifica√ß√£o OK/ALERTA de folga""" if folga_req <= 0: st.info("Sem folga m√≠nima definida.") return if clear_min + 1e-6 >= folga_req: st.success(f"üü¢ **OK** ‚Äî Folga m√≠nima {clear_min:.2f} m ‚â• exigida {folga_req:.2f} m") else: st.warning(f"üü† **ALERTA** ‚Äî Folga m√≠nima {clear_min:.2f} m < exigida {folga_req:.2f} m") # ============================================ # ===== FUN√á√ïES CATEN√ÅRIA AVAN√áADA ========== # ============================================ def effective_w(w_vert_Npm, p_wind_Npm=0.0): """Peso efetivo resultante: w_eff = sqrt(w_vert¬≤ + p_vento¬≤)""" return math.sqrt(w_vert_Npm**2 + p_wind_Npm**2) def catenary_root_xc(a: float, L: float, dy: float, max_iter: int = 80, tol: float = 1e-10) -> float: """ Resolve f(xc) = a[cosh((L-xc)/a) - cosh(xc/a)] - dy = 0. Tenta bisse√ß√£o em [0, L]; se n√£o bracketa, usa secante/Newton com expans√£o. """ def f(xc): return a*(math.cosh((L - xc)/a) - math.cosh(xc/a)) - dy # 1) Tentar bracketing natural [0, L] x0, x1 = 0.0, L f0, f1 = f(x0), f(x1) if f0 == 0.0: return x0 if f1 == 0.0: return x1 if f0 * f1 < 0: # Bisse√ß√£o segura for _ in range(max_iter): xm = 0.5*(x0+x1) fm = f(xm) if abs(fm) < tol: return xm if f0 * fm < 0: x1, f1 = xm, fm else: x0, f0 = xm, fm return 0.5*(x0+x1) # 2) Secante com expans√£o do intervalo x0, x1 = 0.0, L f0, f1 = f(x0), f(x1) span = max(L, 1.0) left = -10.0*span right = 11.0*span for _ in range(max_iter): # Secante denom = (f1 - f0) if abs(denom) < 1e-14: # Chutar para o meio e seguir x2 = 0.5*(x0 + x1) else: x2 = x1 - f1*(x1 - x0)/denom # Manter dentro de limites razo√°veis x2 = min(max(x2, left), right) f2 = f(x2) if abs(f2) < tol: return x2 x0, f0 = x1, f1 x1, f1 = x2, f2 # 3) Newton a partir do meio (fallback) xc = 0.5*L for _ in range(max_iter): u = (L - xc)/a v = xc/a fx = a*(math.cosh(u) - math.cosh(v)) - dy dfx = -(math.sinh(u) + math.sinh(v)) # derivada correta if abs(dfx) < 1e-14: break step = fx/dfx xc_new = xc - step if abs(xc_new - xc) < tol: return xc_new xc = xc_new return xc # retorna melhor que encontrou def compute_catenary_from_H(L, H_left, H_right, delta_solo, w_vert_Npm, p_wind_Npm, H_horiz_N): """ Calcula a caten√°ria completa com entrada por Tens√£o Horizontal H (N). Retorna dicion√°rio com curva, flechas, folga m√≠nima, tens√µes etc. """ # Valida√ß√µes de entrada if L <= 0: raise ValueError("O v√£o L deve ser > 0.") if H_left < 0 or H_right < 0: raise ValueError("As alturas dos apoios n√£o podem ser negativas.") if abs(delta_solo) > max(H_left, H_right) * 2: raise ValueError("O desn√≠vel do solo parece muito grande em rela√ß√£o √†s alturas dos apoios.") # Alturas absolutas dos pontos de fixa√ß√£o (refer√™ncia: solo √† esquerda = 0) yL = H_left yR = delta_solo + H_right dy = yR - yL w_eff = effective_w(w_vert_Npm, p_wind_Npm) # N/m if w_eff <= 0: raise ValueError("O peso efetivo do cabo deve ser > 0.") if H_horiz_N <= 0: raise ValueError("A tens√£o horizontal H deve ser > 0.") a = H_horiz_N / w_eff # par√¢metro da caten√°ria (m) # Valida√ß√£o de par√¢metros para evitar overflow matem√°tico if a < 0.01: raise ValueError("Tens√£o horizontal muito baixa para este peso de cabo - resultaria em flecha excessiva.") if a > L * 100: raise ValueError("Tens√£o horizontal extremamente alta - verifique os valores de entrada.") if abs(dy) > a * 10: raise ValueError("Diferen√ßa de altura entre apoios muito grande para esta tens√£o horizontal.") try: # Teste preliminary para argumentos das fun√ß√µes hiperb√≥licas max_arg = max(L/(2*a), abs(dy)/a) + 1 if max_arg > 500: # limite para evitar overflow em cosh/sinh raise ValueError("Par√¢metros resultariam em valores matem√°ticos extremos - ajuste a tens√£o horizontal.") except (OverflowError, ValueError): raise ValueError("Combina√ß√£o de par√¢metros inv√°lida - ajuste a tens√£o horizontal ou o v√£o.") # Resolver xc pela condi√ß√£o de desn√≠vel entre apoios xc = catenary_root_xc(a=a, L=L, dy=dy) # yc pela altura √† esquerda: yL = yc + a cosh(xc/a) yc = yL - a*math.cosh(xc/a) # Perfis x = np.linspace(0.0, L, 501) y_cat = yc + a*np.cosh((x - xc)/a) # altura absoluta (referente ao solo √† esquerda) ground = (delta_solo / L) * x # solo linear chord = yL + (yR - yL) * (x / L) # corda entre apoios sag_vs_chord = chord - y_cat # flecha relativa √† corda clearance = y_cat - ground # folga ao solo # Resultados principais idx_max_sag = int(np.argmax(sag_vs_chord)) idx_min_clear = int(np.argmin(clearance)) sag_meio = float((yL + yR)/2 - (yc + a*math.cosh((L/2 - xc)/a))) # flecha no meio em rela√ß√£o √† corda sag_max = float(sag_vs_chord[idx_max_sag]) x_sag_max = float(x[idx_max_sag]) clear_min = float(clearance[idx_min_clear]) x_clear_min = float(x[idx_min_clear]) # For√ßas: componentes de tra√ß√£o nos apoios # Componente vertical = w_eff * a * sinh(|x - xc|/a), horizontal = H V_left = w_eff * a * math.sinh(abs(0.0 - xc)/a) V_right = w_eff * a * math.sinh(abs(L - xc)/a) Hh = float(H_horiz_N) T_left = float(math.hypot(Hh, V_left)) T_right = float(math.hypot(Hh, V_right)) df = pd.DataFrame({ "x (m)": x, "Solo (m)": ground, "Corda (m)": chord, "Caten√°ria (m)": y_cat, "Flecha vs Corda (m)": sag_vs_chord, "Folga ao Solo (m)": clearance }) return { "a (m)": float(a), "xc (m)": float(xc), "yc (m)": float(yc), "w_eff (N/m)": float(w_eff), "sag_meio (m)": float(sag_meio), "sag_max (m)": float(sag_max), "x_sag_max (m)": float(x_sag_max), "clear_min (m)": float(clear_min), "x_clear_min (m)": float(x_clear_min), "T_left (N)": T_left, "T_right (N)": T_right, "H_horizontal (N)": Hh, "curve": df } def compute_catenary_from_mid_sag(L, H_left, H_right, delta_solo, w_vert_Npm, p_wind_Npm, sag_mid_target): """ Caso especial: usa flecha no meio (em rela√ß√£o √† corda) para estimar 'a' em APOIOS NIVELADOS (aprox). Para apoios desnivelados, ajusta numericamente por busca de a que reproduza a flecha no meio. """ yL = H_left yR = delta_solo + H_right dy = yR - yL w_eff = effective_w(w_vert_Npm, p_wind_Npm) if w_eff <= 0: raise ValueError("w_eff deve ser > 0.") # Fun√ß√£o objetivo: diferen√ßa entre sag_no_meio(a) e alvo def sag_middle_for_a(a): xc = catenary_root_xc(a, L, dy) yc = yL - a*math.cosh(xc/a) y_mid = yc + a*math.cosh((L/2 - xc)/a) chord_mid = (yL + yR)/2 return chord_mid - y_mid # Busca de 'a' por bisse√ß√£o em escala ampla (garantir sinal trocado) # Come√ßa com a ~ L/10 at√© 20*L a_low, a_high = 0.01*L, 20.0*L f_low = sag_middle_for_a(a_low) - sag_mid_target f_high = sag_middle_for_a(a_high) - sag_mid_target # expandir se necess√°rio tries = 0 while f_low*f_high > 0 and tries < 30: a_low *= 0.5 a_high *= 2.0 f_low = sag_middle_for_a(a_low) - sag_mid_target f_high = sag_middle_for_a(a_high) - sag_mid_target tries += 1 if f_low*f_high > 0: raise ValueError("N√£o foi poss√≠vel ajustar 'a' para a flecha informada. Verifique os dados.") for _ in range(80): a_mid = 0.5*(a_low + a_high) f_mid = sag_middle_for_a(a_mid) - sag_mid_target if abs(f_mid) < 1e-7 or abs(a_high - a_low) < 1e-7: a = a_mid break if f_low*f_mid < 0: a_high, f_high = a_mid, f_mid else: a_low, f_low = a_mid, f_mid else: a = 0.5*(a_low + a_high) Hh = w_eff * a return compute_catenary_from_H(L, H_left, H_right, delta_solo, w_vert_Npm, p_wind_Npm, Hh) def compute_catenary_from_length(L, H_left, H_right, delta_solo, w_vert_Npm, p_wind_Npm, cable_length): """ Resolve a e xc por: F1: a[cosh((L-xc)/a) - cosh(xc/a)] - dy = 0 F2: a[sinh((L-xc)/a) + sinh(xc/a)] - S = 0 Retorna mesma estrutura do modo por H. """ yL = H_left yR = delta_solo + H_right dy = yR - yL w_eff = effective_w(w_vert_Npm, p_wind_Npm) if cable_length <= L: raise ValueError("Comprimento do cabo deve ser maior que o v√£o L.") if w_eff <= 0: raise ValueError("w_eff deve ser > 0.") # Palpite inicial: usar sag ~ 0.02*L para come√ßar f0 = max(0.02*L, 0.01) a0 = (L**2)/(8.0*f0) # parab√≥lico como chute xc0 = catenary_root_xc(a0, L, dy) a, xc = a0, xc0 for _ in range(60): u = (L - xc)/a v = xc/a F1 = a*(math.cosh(u) - math.cosh(v)) - dy F2 = a*(math.sinh(u) + math.sinh(v)) - cable_length if max(abs(F1), abs(F2)) < 1e-10: break # Jacobiano dF1_da = (math.cosh(u) - u*math.sinh(u)) + (-math.cosh(v) + v*math.sinh(v)) dF1_dxc = -(math.sinh(u) + math.sinh(v)) dF2_da = (math.sinh(u) - u*math.cosh(u)) + (math.sinh(v) - v*math.cosh(v)) dF2_dxc = -math.cosh(u) + math.cosh(v) # Resolver 2x2 - Usar sinais da vers√£o original funcional det = dF1_da*dF2_dxc - dF1_dxc*dF2_da if abs(det) < 1e-14: break # evita explos√£o; sai com o melhor que deu da = (-F1*dF2_dxc + dF1_dxc*(-F2)) / det dxc = (-dF1_da*(-F2) + (-F1)*dF2_da) / det # Atualiza com amortecimento step = 1.0 for _ in range(5): a_try = a + step*da xc_try = xc + step*dxc try: u_try = (L - xc_try)/a_try v_try = xc_try/a_try F1_try = a_try*(math.cosh(u_try) - math.cosh(v_try)) - dy F2_try = a_try*(math.sinh(u_try) + math.sinh(v_try)) - cable_length if abs(F1_try) + abs(F2_try) < abs(F1) + abs(F2): a, xc = a_try, xc_try break except Exception: pass step *= 0.5 Hh = w_eff * a return compute_catenary_from_H(L, H_left, H_right, delta_solo, w_vert_Npm, p_wind_Npm, Hh) # ======= RELAT√ìRIO T√âCNICO (PDF & WORD) ======= def _fig_to_png_bytes(fig): import io buf = io.BytesIO() fig.savefig(buf, format="png", dpi=160, bbox_inches="tight") buf.seek(0) return buf def build_pdf_report_bytes(contexto: dict, resultados: dict, df_perfil: pd.DataFrame, fig) -> bytes: """ Gera PDF com base no √∫ltimo c√°lculo. contexto: infos de entrada (geometria, cabo, m√©todo, folga requerida etc.) resultados: dicion√°rio retornado por compute_* (sag, folga, tens√µes, etc.) df_perfil: DataFrame com perfil (solo/corda/caten√°ria) fig: figura matplotlib exibida no app """ import io buf_pdf = io.BytesIO() doc = SimpleDocTemplate(buf_pdf, pagesize=A4, topMargin=18*mm, bottomMargin=18*mm, leftMargin=18*mm, rightMargin=18*mm) estilo = getSampleStyleSheet() estilo_titulo = ParagraphStyle("titulo", parent=estilo["Heading1"], alignment=0, spaceAfter=8, fontSize=16) estilo_sub = ParagraphStyle("sub", parent=estilo["Normal"], textColor=colors.grey, spaceAfter=6) estilo_hdr = ParagraphStyle("hdr", parent=estilo["Heading3"], spaceBefore=10, spaceAfter=6) elems = [] # Cabe√ßalho titulo = "Relat√≥rio T√©cnico ‚Äî Caten√°ria (V√£o, Flecha, Folga e Tra√ß√£o)" elems.append(Paragraph(titulo, estilo_titulo)) meta = f"{contexto.get('obra','')} ‚Ä¢ {contexto.get('cliente','')} ‚Ä¢ {datetime.now().strftime('%d/%m/%Y %H:%M')}" elems.append(Paragraph(meta, estilo_sub)) # Tabela de entradas entradas = [ ["Geometria", f"L = {contexto['L']:.2f} m | H_esq = {contexto['H_esq']:.2f} m | H_dir = {contexto['H_dir']:.2f} m | Œîh_solo = {contexto['delta_solo']:.2f} m"], ["Cabo", f"{contexto['cabo_nome']} | w = {contexto['w_kgpm']:.3f} kg/m ({contexto['w_Npm']:.2f} N/m) | p_v = {contexto['p_vento']:.1f} N/m"], ["M√©todo", contexto['metodo_descr']], ["Norma/Folga", f"Folga m√≠nima exigida = {contexto['folga_req']:.2f} m | Crit√©rio = {contexto.get('criterio','NBR 15992')}"], ] t1 = Table(entradas, colWidths=[35*mm, 140*mm]) t1.setStyle(TableStyle([ ("BOX", (0,0), (-1,-1), 0.5, colors.black), ("INNERGRID", (0,0), (-1,-1), 0.25, colors.grey), ("BACKGROUND", (0,0), (0,-1), colors.whitesmoke), ("VALIGN", (0,0), (-1,-1), "TOP"), ("LEFTPADDING", (0,0), (-1,-1), 6), ("RIGHTPADDING", (0,0), (-1,-1), 6), ("FONTSIZE", (0,0), (-1,-1), 9), ])) elems += [Spacer(1, 4*mm), t1] # Resultados principais elems.append(Spacer(1, 4*mm)) elems.append(Paragraph("Resultados Principais", estilo_hdr)) ok_txt = "OK" if resultados["clear_min (m)"] + 1e-6 >= contexto["folga_req"] else "ALERTA" res_tab = [ ["Flecha no meio (vs corda)", f"{resultados['sag_meio (m)']:.2f} m"], ["Flecha m√°xima / posi√ß√£o x", f"{resultados['sag_max (m)']:.2f} m @ x = {resultados['x_sag_max (m)']:.2f} m"], ["Folga m√≠nima ao solo / posi√ß√£o x", f"{resultados['clear_min (m)']:.2f} m @ x = {resultados['x_clear_min (m)']:.2f} m ‚Üí {ok_txt}"], ["Tens√£o horizontal H", f"{resultados['H_horizontal (N)']/1000:.3f} kN"], ["Tra√ß√£o no apoio esquerdo/direito", f"{resultados['T_left (N)']/1000:.3f} / {resultados['T_right (N)']/1000:.3f} kN"], ["Par√¢metro a / xc", f"a = {resultados['a (m)']:.3f} m | xc = {resultados['xc (m)']:.3f} m"], ] t2 = Table(res_tab, colWidths=[70*mm, 105*mm]) t2.setStyle(TableStyle([ ("BOX", (0,0), (-1,-1), 0.5, colors.black), ("INNERGRID", (0,0), (-1,-1), 0.25, colors.grey), ("BACKGROUND", (0,0), (0,0), colors.whitesmoke), ("BACKGROUND", (0,2), (0,2), colors.whitesmoke), ("LEFTPADDING", (0,0), (-1,-1), 6), ("RIGHTPADDING", (0,0), (-1,-1), 6), ("FONTSIZE", (0,0), (-1,-1), 9), ])) elems += [Spacer(1, 2*mm), t2] # Gr√°fico elems.append(Spacer(1, 4*mm)) elems.append(Paragraph("Gr√°fico do V√£o", estilo_hdr)) img_buf = _fig_to_png_bytes(fig) elems.append(RLImage(img_buf, width=170*mm, preserveAspectRatio=True)) # Observa√ß√µes e assinatura elems += [ Spacer(1, 4*mm), Paragraph("Observa√ß√µes", estilo_hdr), Paragraph(contexto.get("obs","‚Äî"), estilo["Normal"]), Spacer(1, 6*mm), Paragraph(f"Respons√°vel t√©cnico: {contexto.get('engenheiro','')} ‚Äî CREA: {contexto.get('crea','')}", estilo_sub), ] doc.build(elems) buf_pdf.seek(0) return buf_pdf.getvalue() def pdf_expander_ui(res, df, fig, contexto_base: dict): """Bloco UI para preencher cabe√ßalho e baixar PDF - SEM EXPANDER.""" st.markdown("### üìÑ Relat√≥rio t√©cnico (PDF)") c1, c2 = st.columns(2) with c1: obra = st.text_input("Obra / Identifica√ß√£o", value=contexto_base.get("obra","")) cliente = st.text_input("Cliente / Unidade", value=contexto_base.get("cliente","")) engenheiro = st.text_input("Engenheiro respons√°vel", value=contexto_base.get("engenheiro","")) with c2: crea = st.text_input("CREA", value=contexto_base.get("crea","")) obs = st.text_area("Observa√ß√µes", value=contexto_base.get("obs",""), height=90) contexto = dict(contexto_base) contexto.update({"obra": obra, "cliente": cliente, "engenheiro": engenheiro, "crea": crea, "obs": obs}) col_btn, col_download = st.columns([1, 1]) with col_btn: if st.button("üìÑ Gerar PDF do relat√≥rio", type="secondary", use_container_width=True): try: pdf_bytes = build_pdf_report_bytes(contexto, res, df, fig) st.session_state["pdf_report_data"] = pdf_bytes st.success("‚úÖ PDF gerado!") except Exception as e: st.error(f"Falha: {e}") with col_download: if "pdf_report_data" in st.session_state: st.download_button( "‚¨áÔ∏è Baixar PDF", data=st.session_state["pdf_report_data"], file_name="relatorio_catenaria.pdf", mime="application/pdf", use_container_width=True ) def build_word_report_bytes(contexto: dict, resultados: dict, df_perfil: pd.DataFrame, fig) -> bytes: """ Gera relat√≥rio Word com base no √∫ltimo c√°lculo. contexto: infos de entrada (geometria, cabo, m√©todo, folga requerida etc.) resultados: dicion√°rio retornado por compute_* (sag, folga, tens√µes, etc.) df_perfil: DataFrame com perfil (solo/corda/caten√°ria) fig: figura matplotlib exibida no app """ import io from datetime import datetime # Criar novo documento doc = Document() # === CABE√áALHO === # T√≠tulo principal titulo = doc.add_heading('Relat√≥rio T√©cnico ‚Äî Caten√°ria (V√£o, Flecha, Folga e Tra√ß√£o)', level=0) titulo.alignment = WD_ALIGN_PARAGRAPH.CENTER # Meta informa√ß√µes meta_info = f"{contexto.get('obra','')} ‚Ä¢ {contexto.get('cliente','')} ‚Ä¢ {datetime.now().strftime('%d/%m/%Y %H:%M')}" meta_para = doc.add_paragraph(meta_info) meta_para.alignment = WD_ALIGN_PARAGRAPH.CENTER # Linha em branco doc.add_paragraph() # === DADOS DE ENTRADA === doc.add_heading('Dados de Entrada', level=1) # Tabela de entradas entrada_table = doc.add_table(rows=1, cols=2) entrada_table.style = 'Light Grid Accent 1' # Cabe√ßalho da tabela header_cells = entrada_table.rows[0].cells header_cells[0].text = 'Par√¢metro' header_cells[1].text = 'Valor' # Dados da entrada entradas_data = [ ['Geometria', f"L = {contexto['L']:.2f} m | H_esq = {contexto['H_esq']:.2f} m | H_dir = {contexto['H_dir']:.2f} m | Œîh_solo = {contexto['delta_solo']:.2f} m"], ['Cabo', f"{contexto['cabo_nome']} | w = {contexto['w_kgpm']:.3f} kg/m ({contexto['w_Npm']:.2f} N/m) | p_v = {contexto['p_vento']:.1f} N/m"], ['M√©todo', contexto['metodo_descr']], ['Norma/Folga', f"Folga m√≠nima exigida = {contexto['folga_req']:.2f} m | Crit√©rio = {contexto.get('criterio','NBR 15992')}"] ] for param, valor in entradas_data: row_cells = entrada_table.add_row().cells row_cells[0].text = param row_cells[1].text = valor # === RESULTADOS PRINCIPAIS === doc.add_heading('Resultados Principais', level=1) # Tabela de resultados result_table = doc.add_table(rows=1, cols=2) result_table.style = 'Light Grid Accent 1' # Cabe√ßalho header_cells = result_table.rows[0].cells header_cells[0].text = 'Par√¢metro' header_cells[1].text = 'Resultado' # Status da folga ok_txt = "OK" if resultados["clear_min (m)"] + 1e-6 >= contexto["folga_req"] else "ALERTA" # Dados dos resultados resultados_data = [ ['Flecha no meio (vs corda)', f"{resultados['sag_meio (m)']:.2f} m"], ['Flecha m√°xima / posi√ß√£o x', f"{resultados['sag_max (m)']:.2f} m @ x = {resultados['x_sag_max (m)']:.2f} m"], ['Folga m√≠nima ao solo / posi√ß√£o x', f"{resultados['clear_min (m)']:.2f} m @ x = {resultados['x_clear_min (m)']:.2f} m ‚Üí {ok_txt}"], ['Tens√£o horizontal H', f"{resultados['H_horizontal (N)']/1000:.3f} kN"], ['Tra√ß√£o no apoio esquerdo/direito', f"{resultados['T_left (N)']/1000:.3f} / {resultados['T_right (N)']/1000:.3f} kN"], ['Par√¢metro a / xc', f"a = {resultados['a (m)']:.3f} m | xc = {resultados['xc (m)']:.3f} m"] ] for param, resultado in resultados_data: row_cells = result_table.add_row().cells row_cells[0].text = param row_cells[1].text = resultado # === GR√ÅFICO === doc.add_heading('Gr√°fico do V√£o', level=1) # Salvar gr√°fico como imagem tempor√°ria img_buf = _fig_to_png_bytes(fig) doc.add_picture(img_buf, width=Inches(6.5)) # === OBSERVA√á√ïES === doc.add_heading('Observa√ß√µes', level=1) doc.add_paragraph(contexto.get("obs", "‚Äî")) # === ASSINATURA === doc.add_paragraph() assinatura = f"Respons√°vel t√©cnico: {contexto.get('engenheiro', '')} ‚Äî CREA: {contexto.get('crea', '')}" assinatura_para = doc.add_paragraph(assinatura) assinatura_para.alignment = WD_ALIGN_PARAGRAPH.RIGHT # Salvar em bytes buf_word = io.BytesIO() doc.save(buf_word) buf_word.seek(0) return buf_word.getvalue() def word_expander_ui(res, df, fig, contexto_base: dict): """Bloco UI para preencher cabe√ßalho e baixar Word - SEM EXPANDER.""" st.markdown("### üìù Relat√≥rio t√©cnico (Word)") c1, c2 = st.columns(2) with c1: obra = st.text_input("Obra / Identifica√ß√£o", value=contexto_base.get("obra",""), key="word_obra") cliente = st.text_input("Cliente / Unidade", value=contexto_base.get("cliente",""), key="word_cliente") engenheiro = st.text_input("Engenheiro respons√°vel", value=contexto_base.get("engenheiro",""), key="word_eng") with c2: crea = st.text_input("CREA", value=contexto_base.get("crea",""), key="word_crea") obs = st.text_area("Observa√ß√µes", value=contexto_base.get("obs",""), height=90, key="word_obs") contexto = dict(contexto_base) contexto.update({"obra": obra, "cliente": cliente, "engenheiro": engenheiro, "crea": crea, "obs": obs}) col_btn, col_download = st.columns([1, 1]) with col_btn: if st.button("üìù Gerar Word do relat√≥rio", type="secondary", key="word_btn", use_container_width=True): try: word_bytes = build_word_report_bytes(contexto, res, df, fig) st.session_state["word_report_data"] = word_bytes st.success("‚úÖ Word gerado!") except Exception as e: st.error(f"Falha: {e}") with col_download: if "word_report_data" in st.session_state: st.download_button( "‚¨áÔ∏è Baixar Word", data=st.session_state["word_report_data"], file_name="relatorio_catenaria.docx", mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document", use_container_width=True, key="word_download" ) st.set_page_config(page_title="Altura de Estrutura ‚Äî Campo", page_icon="üìè", layout="centered") # --- Session state management (no database) if "show_success" not in st.session_state: st.session_state.show_success = None if "historico_altura" not in st.session_state: st.session_state.historico_altura = [] if "historico_terreno" not in st.session_state: st.session_state.historico_terreno = [] st.title("üìè Calculadora de Altura de Estrutura (Campo)") # === Criar abas === tabs = st.tabs(["üèóÔ∏è Calculadora de Altura", "üóª An√°lise de Terreno", "ü™¢ Caten√°ria Avan√ßada", "‚ö° Seguran√ßa El√©trica NBR 15992"]) # ======================================= # ======== ABA 1: CALCULADORA ========== # ======================================= with tabs[0]: st.markdown( """ Use sua trena a laser **Wesco 50 m** (sem inclin√¥metro) com um destes m√©todos: 1. **Pit√°goras (S e D)** ‚Äî quando voc√™ tem a **dist√¢ncia inclinada S** at√© o topo e a **dist√¢ncia horizontal D** at√© a base. 2. **√Çngulo + Dist√¢ncia horizontal (Œ∏ e D)** ‚Äî usando um app de **inclin√¥metro** no celular para obter o **√¢ngulo Œ∏** at√© o topo. 3. **Sombra (regra de 3)** ‚Äî em terreno plano com sol, comparando sua altura e sombra com a do poste. 4. **Dist√¢ncia inclinada + √Çngulo (S e Œ∏)** ‚Äî usando **S** da trena e **Œ∏** do inclin√¥metro embutido. > Sempre some a **altura do equipamento (h_inst)** (altura da trena/celular em rela√ß√£o ao solo). """ ) metodo = st.sidebar.selectbox( "M√©todo de Medi√ß√£o", [ "1) Pit√°goras (S e D)", "2) √Çngulo + Dist√¢ncia horizontal (Œ∏ e D)", "3) Sombra (regra de 3)", "4) Dist√¢ncia inclinada + √Çngulo (S e Œ∏)" ], index=0 ) st.sidebar.markdown("### Ajustes de Terreno") declive = st.sidebar.checkbox("Considerar desn√≠vel de terreno (observador em n√≠vel diferente da base)?", value=False) delta_terreno = 0.0 if declive: delta_terreno = st.sidebar.number_input( "Œîh (m) ‚Äî positivo se voc√™ est√° **acima** da base, negativo se est√° **abaixo**", value=0.0, step=0.1, format="%.2f" ) st.sidebar.markdown("### Altura da trena/celular") h_inst = st.sidebar.number_input("h_inst (m) ‚Äî altura da trena/celular em rela√ß√£o ao solo", value=1.50, step=0.1, format="%.2f") st.markdown("---") def validar_pos(val, nome): """Valida√ß√£o b√°sica para valores positivos""" if val <= 0: st.error(f"‚ùå {nome} deve ser maior que zero.") return False return True def validar_pitagoras(S, D): """Valida√ß√£o espec√≠fica para m√©todo Pit√°goras""" errors = [] warnings = [] # Valida√ß√µes b√°sicas if S <= 0: errors.append("S (dist√¢ncia inclinada) deve ser maior que zero") if D <= 0: errors.append("D (dist√¢ncia horizontal) deve ser maior que zero") # Valida√ß√£o geom√©trica essencial if S < D: errors.append("Geometricamente inv√°lido: S (inclinada) n√£o pode ser menor que D (horizontal)") # C√°lculo correto do √¢ngulo e avisos baseados na geometria real if S >= D and S > 0 and D > 0: # Œ∏ = arccos(D/S) - √¢ngulo de eleva√ß√£o correto theta_rad = math.acos(D / S) theta_deg = math.degrees(theta_rad) # Avisos para √¢ngulos extremos if theta_deg < 3: # √Çngulo muito baixo warnings.append(f"√Çngulo muito baixo ({theta_deg:.1f}¬∞). Para maior precis√£o, posicione-se mais pr√≥ximo ou use o m√©todo do √¢ngulo") elif theta_deg > 80: # √Çngulo muito √≠ngreme warnings.append(f"√Çngulo muito √≠ngreme ({theta_deg:.1f}¬∞). Para maior precis√£o, posicione-se mais longe") elif S == D: # Caso especial: √¢ngulo = 0¬∞ warnings.append("S = D significa √¢ngulo de 0¬∞ (horizontal). Verifique se essa √© uma medi√ß√£o realista") # Limites do equipamento (Wesco 50m) if S > 50: errors.append("S excede alcance da trena (50m). Posicione-se mais pr√≥ximo") if D > 50: errors.append("D excede alcance da trena (50m). Posicione-se mais pr√≥ximo") return errors, warnings def validar_angulo(D, theta): """Valida√ß√£o espec√≠fica para m√©todo do √¢ngulo""" errors = [] warnings = [] # Valida√ß√µes b√°sicas if D <= 0: errors.append("D (dist√¢ncia horizontal) deve ser maior que zero") # Valida√ß√µes do √¢ngulo - prevenindo problemas com tangente if theta < -89 or theta > 89: errors.append("√Çngulo deve estar entre -89¬∞ e 89¬∞ (tangente indefinida em ¬±90¬∞)") elif abs(theta) >= 87: # Pr√≥ximo aos limites perigosos errors.append(f"√Çngulo muito pr√≥ximo de ¬±90¬∞ ({theta}¬∞). Use valores entre -87¬∞ e 87¬∞ para evitar resultados extremos") elif theta == 0: warnings.append("√Çngulo = 0¬∞ significa estrutura na altura dos olhos. Verifique a medi√ß√£o") elif theta < 0: warnings.append("√Çngulo negativo indica estrutura abaixo do n√≠vel dos olhos") elif theta > 80: warnings.append("√Çngulo √≠ngreme (>80¬∞). Para maior precis√£o, considere posicionar-se mais longe") elif abs(theta) < 3: warnings.append("√Çngulo muito baixo (<3¬∞). Para maior precis√£o, considere posicionar-se mais pr√≥ximo") # Limites do equipamento if D > 50: errors.append("D excede alcance da trena (50m). Posicione-se mais pr√≥ximo") # Verifica√ß√£o de altura resultante extrema (s√≥ se o √¢ngulo for v√°lido) if D > 0 and abs(theta) < 87: altura_estimada = D * math.tan(math.radians(theta)) if abs(altura_estimada) > 200: warnings.append(f"Altura estimada muito alta ({altura_estimada:.1f}m). Verifique as medi√ß√µes") return errors, warnings def validar_sombra(sombra_poste, sombra_pessoa, sua_altura): """Valida√ß√£o espec√≠fica para m√©todo da sombra""" errors = [] warnings = [] # Valida√ß√µes b√°sicas if sombra_poste <= 0: errors.append("Sombra do poste deve ser maior que zero") if sombra_pessoa <= 0: errors.append("Sua sombra deve ser maior que zero") if sua_altura <= 0: errors.append("Sua altura deve ser maior que zero") # Valida√ß√µes de propor√ß√£o if sua_altura > 0 and sombra_pessoa > 0: proporcao = sua_altura / sombra_pessoa if proporcao < 0.3: # Sombra muito longa (baixa propor√ß√£o) warnings.append("Sombra muito longa comparada √† altura. Evite hor√°rios pr√≥ximos ao nascer/p√¥r do sol para maior precis√£o") elif proporcao > 3: # Sombra muito curta (alta propor√ß√£o) warnings.append("Sombra muito curta. Evite hor√°rios pr√≥ximos ao meio-dia para maior precis√£o") # Verifica√ß√µes de realismo if sua_altura < 1.0 or sua_altura > 2.5: warnings.append("Altura pessoal fora do intervalo t√≠pico (1,0-2,5m). Verifique o valor") if sombra_poste > 100: warnings.append("Sombra do poste muito longa (>100m). Verifique a medi√ß√£o") if sombra_pessoa > 10: warnings.append("Sua sombra muito longa (>10m). Verifique a medi√ß√£o") return errors, warnings def exibir_validacao(errors, warnings): """Exibe erros e avisos de valida√ß√£o""" if errors: for error in errors: st.error(f"‚ùå {error}") return False if warnings: for warning in warnings: st.warning(f"‚ö†Ô∏è {warning}") return True def add_historico(linha: dict): st.session_state.historico_altura.append(linha) st.session_state.show_success = f"‚úÖ Altura estimada da estrutura: **{linha['Altura (m)']:.2f} m**" if metodo.startswith("1"): st.subheader("1) Pit√°goras (S e D)") col1, col2 = st.columns(2) with col1: S = st.number_input("S (m) ‚Äî dist√¢ncia **inclinada** at√© o topo", value=20.0, min_value=0.0, step=0.1, format="%.2f") with col2: D = st.number_input("D (m) ‚Äî dist√¢ncia **horizontal** at√© a base", value=15.0, min_value=0.0, step=0.1, format="%.2f") st.caption("F√≥rmula: Altura = ‚àö(S¬≤ ‚àí D¬≤) + h_inst ¬± Œîh_terreno") if st.button("Calcular altura", type="primary", key="calc_pitagoras"): errors, warnings = validar_pitagoras(S, D) if exibir_validacao(errors, warnings): try: altura_vertical = math.sqrt(S**2 - D**2) H = altura_vertical + h_inst + delta_terreno add_historico({ "M√©todo": "Pit√°goras (S e D)", "S (m)": S, "D (m)": D, "Œ∏ (graus)": np.nan, "h_inst (m)": h_inst, "Œîh terreno (m)": delta_terreno, "Altura (m)": H }) except ValueError: st.error("‚ùå Erro nos c√°lculos. Verifique se S¬≤ ‚â• D¬≤.") elif metodo.startswith("2"): st.subheader("2) √Çngulo + Dist√¢ncia horizontal (Œ∏ e D)") col1, col2 = st.columns(2) with col1: D = st.number_input("D (m) ‚Äî dist√¢ncia **horizontal** at√© a base", value=15.0, min_value=0.0, step=0.1, format="%.2f") with col2: theta = st.number_input("Œ∏ (graus) ‚Äî √¢ngulo do celular apontando para o topo", value=30.0, step=0.1, format="%.2f") st.caption("F√≥rmula: Altura = D ¬∑ tan(Œ∏) + h_inst ¬± Œîh_terreno") if st.button("Calcular altura", type="primary", key="calc_angulo"): errors, warnings = validar_angulo(D, theta) if exibir_validacao(errors, warnings): try: rad = math.radians(theta) H = D * math.tan(rad) + h_inst + delta_terreno add_historico({ "M√©todo": "√Çngulo + D", "S (m)": np.nan, "D (m)": D, "Œ∏ (graus)": theta, "h_inst (m)": h_inst, "Œîh terreno (m)": delta_terreno, "Altura (m)": H }) except (ValueError, ZeroDivisionError): st.error("‚ùå Erro nos c√°lculos trigonom√©tricos. Verifique o √¢ngulo.") elif metodo.startswith("3"): st.subheader("3) Sombra (regra de 3)") col1, col2 = st.columns(2) with col1: sombra_poste = st.number_input("Sombra do poste (m)", value=10.0, min_value=0.0, step=0.1, format="%.2f") with col2: sombra_pessoa = st.number_input("Sua sombra (m)", value=1.8, min_value=0.0, step=0.1, format="%.2f") sua_altura = st.number_input("Sua altura (m)", value=1.80, min_value=0.0, step=0.01, format="%.2f") st.caption("F√≥rmula: Altura_poste = Sombra_poste √ó (Sua_altura / Sua_sombra) + h_inst ¬± Œîh_terreno") if st.button("Calcular altura", type="primary", key="calc_sombra"): errors, warnings = validar_sombra(sombra_poste, sombra_pessoa, sua_altura) if exibir_validacao(errors, warnings): try: base = sombra_poste * (sua_altura / sombra_pessoa) H = base + h_inst + delta_terreno add_historico({ "M√©todo": "Sombra (regra de 3)", "S (m)": np.nan, "D (m)": np.nan, "Œ∏ (graus)": np.nan, "h_inst (m)": h_inst, "Œîh terreno (m)": delta_terreno, "Altura (m)": H, "Sombra poste (m)": sombra_poste, "Sua sombra (m)": sombra_pessoa, "Sua altura (m)": sua_altura }) except (ValueError, ZeroDivisionError): st.error("‚ùå Erro no c√°lculo da regra de tr√™s. Verifique os valores das sombras.") else: # M√©todo 4: Dist√¢ncia inclinada + √Çngulo (S e Œ∏) st.subheader("4) Dist√¢ncia inclinada + √Çngulo (S e Œ∏)") col1, col2 = st.columns(2) with col1: S = st.number_input("S (m) ‚Äî dist√¢ncia **inclinada** at√© o ponto mirado", value=20.0, min_value=0.0, step=0.1, format="%.2f", key="S_metodo4") with col2: theta = st.number_input("Œ∏ (graus) ‚Äî √¢ngulo do inclin√¥metro (use **negativo** se mirar p/ baixo)", value=30.0, step=0.1, format="%.2f", key="theta_metodo4") st.caption("F√≥rmulas: Œîh = S¬∑sen(Œ∏) | D = S¬∑cos(Œ∏) | Altura = Œîh + h_inst ¬± Œîh_terreno") if st.button("Calcular altura", type="primary", key="calc_s_angulo"): if validar_pos(S, "S"): try: rad = math.radians(theta) delta_h = S * math.sin(rad) D_calc = S * math.cos(rad) H = delta_h + h_inst + delta_terreno add_historico({ "M√©todo": "S + Œ∏", "S (m)": S, "D (m)": D_calc, "Œ∏ (graus)": theta, "h_inst (m)": h_inst, "Œîh terreno (m)": delta_terreno, "Altura (m)": H }) # Show additional calculation details if st.session_state.show_success: st.info(f"Œîh (vertical): **{delta_h:.2f} m** | D (horizontal): **{D_calc:.2f} m**") except (ValueError, ZeroDivisionError): st.error("‚ùå Erro nos c√°lculos trigonom√©tricos. Verifique os valores.") # Display success message if available if st.session_state.show_success: st.success(st.session_state.show_success) st.session_state.show_success = None # Clear after displaying st.markdown("---") st.subheader("üßæ Hist√≥rico de medi√ß√µes") if len(st.session_state.historico_altura) == 0: st.info("Sem medi√ß√µes ainda. Fa√ßa um c√°lculo para registrar no hist√≥rico.") else: df = pd.DataFrame(st.session_state.historico_altura) # Ordenar colunas de forma amig√°vel col_order = [ "M√©todo", "Altura (m)", "S (m)", "D (m)", "Œ∏ (graus)", "h_inst (m)", "Œîh terreno (m)", "Sombra poste (m)", "Sua sombra (m)", "Sua altura (m)" ] cols = [c for c in col_order if c in df.columns] + [c for c in df.columns if c not in col_order] df = df[cols] # Show management controls col1, col2 = st.columns([3, 1]) with col2: if st.button("üóëÔ∏è Limpar hist√≥rico", help="Remove todas as medi√ß√µes do hist√≥rico"): st.session_state.historico_altura = [] st.success("‚úÖ Hist√≥rico limpo com sucesso!") st.rerun() st.dataframe(df, width="stretch") # Download XLSX (com prote√ß√£o contra erro) try: buffer = io.BytesIO() with pd.ExcelWriter(buffer, engine="openpyxl") as writer: df.to_excel(writer, sheet_name="Historico", index=False) st.download_button( label="‚¨áÔ∏è Baixar hist√≥rico em XLSX", data=buffer.getvalue(), file_name="historico_altura_estrutura.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" ) except ImportError: # Fallback para CSV se openpyxl n√£o dispon√≠vel csv_data = df.to_csv(index=False) st.download_button( label="‚¨áÔ∏è Baixar hist√≥rico em CSV", data=csv_data, file_name="historico_altura_estrutura.csv", mime="text/csv" ) # ===== VERIFICA√á√ÉO DE ENGASTAMENTO DE POSTES ===== # MOVIDO PARA FORA da condi√ß√£o de hist√≥rico - sempre renderiza st.markdown("---") st.subheader("‚ö° Verifica√ß√£o de Engastamento de Postes") st.markdown( """ **F√≥rmula para verificar altura real do poste:** **e = (L/10) + 0,60 m** Onde: - **L** = comprimento total do poste (metros) - **e** = profundidade do engastamento (m√≠nimo 1,5 metros) Use esta f√≥rmula para verificar se a altura medida corresponde √† altura real do poste considerando a parte enterrada. """ ) col_eng1, col_eng2 = st.columns(2) with col_eng1: altura_medida_poste = st.number_input( "Altura medida do poste (m) ‚Äî do solo at√© o topo", value=12.0, min_value=0.0, step=0.1, format="%.2f", key="altura_medida_poste" ) with col_eng2: comprimento_total_poste = st.number_input( "Comprimento total do poste (m) ‚Äî incluindo parte enterrada", value=0.0, min_value=0.0, step=0.1, format="%.2f", help="Se conhecido, informe o comprimento total do poste", key="comprimento_total_poste" ) if comprimento_total_poste > 0: # Calcular engastamento pela f√≥rmula engastamento_calculado = (comprimento_total_poste / 10.0) + 0.60 engastamento_minimo = max(engastamento_calculado, 1.5) # m√≠nimo 1,5m altura_estimada = comprimento_total_poste - engastamento_minimo st.info( f"üìè **Engastamento calculado**: {engastamento_calculado:.2f} m " f"(m√≠nimo: 1,5 m ‚Üí usar: {engastamento_minimo:.2f} m)" ) st.info( f"üèóÔ∏è **Altura estimada do poste**: {altura_estimada:.2f} m " f"(comprimento total - engastamento)" ) # Compara√ß√£o com altura medida diferenca = abs(altura_medida_poste - altura_estimada) if diferenca <= 0.5: st.success(f"‚úÖ **Verifica√ß√£o OK**: Diferen√ßa de {diferenca:.2f} m (aceit√°vel)") else: st.warning(f"‚ö†Ô∏è **Verificar medi√ß√£o**: Diferen√ßa de {diferenca:.2f} m (>0,5 m)") if st.button("üßÆ Calcular engastamento apenas pela altura medida", key="calc_eng_reverso"): # Engastamento estimado assumindo poste padr√£o L_estimado = altura_medida_poste / 0.85 # assumindo ~85% acima do solo engastamento_est = (L_estimado / 10.0) + 0.60 engastamento_min = max(engastamento_est, 1.5) comprimento_estimado = altura_medida_poste + engastamento_min st.info( f"üìê **Estimativa**: Comprimento total ‚âà {comprimento_estimado:.2f} m " f"(altura medida + engastamento estimado {engastamento_min:.2f} m)" ) # ======================================= # ======= ABA 2: AN√ÅLISE DE TERRENO ==== # ======================================= with tabs[1]: st.subheader("üóª An√°lise de Terreno e Nivelamento") st.markdown( """ **Ferramentas para an√°lise topogr√°fica e nivelamento em campo:** - C√°lculo de declividades e inclina√ß√µes - An√°lise de cotas e diferen√ßas de n√≠vel - Volumes de corte e aterro - Dist√¢ncias corrigidas em terrenos inclinados - Convers√£o entre coordenadas e medi√ß√µes de campo """ ) analise_tipo = st.selectbox( "Tipo de an√°lise", [ "1) Declividade e Inclina√ß√£o", "2) Nivelamento e Cotas", "3) Volume de Corte/Aterro", "4) Dist√¢ncias em Terreno Inclinado", "5) Coordenadas e Triangula√ß√£o" ], index=0 ) def add_hist_terreno(linha: dict): st.session_state.historico_terreno.append(linha) if analise_tipo.startswith("1"): st.subheader("1) C√°lculo de Declividade e Inclina√ß√£o") col1, col2 = st.columns(2) with col1: dist_horizontal = st.number_input("Dist√¢ncia horizontal (m)", value=100.0, min_value=0.1, step=1.0, format="%.2f") with col2: desnivel = st.number_input("Desn√≠vel vertical (m)", value=5.0, step=0.1, format="%.2f") st.markdown("**M√©todos de entrada alternativos:**") usar_angulo = st.checkbox("Calcular a partir de √¢ngulo medido") if usar_angulo: angulo_terreno = st.number_input("√Çngulo de inclina√ß√£o do terreno (¬∞)", value=3.0, step=0.1, format="%.2f") desnivel_calculado = dist_horizontal * math.tan(math.radians(angulo_terreno)) st.info(f"Desn√≠vel calculado: {desnivel_calculado:.2f} m") desnivel = desnivel_calculado if st.button("Calcular declividade", type="primary", key="btn_declividade"): if dist_horizontal > 0: # C√°lculos declividade_perc = (abs(desnivel) / dist_horizontal) * 100 declividade_razao = f"1:{dist_horizontal/abs(desnivel):.1f}" if desnivel != 0 else "1:‚àû" angulo_calc = math.degrees(math.atan(abs(desnivel) / dist_horizontal)) dist_inclinada = math.sqrt(dist_horizontal**2 + desnivel**2) # Classifica√ß√£o da declividade if declividade_perc < 2: classe = "Muito suave" elif declividade_perc < 5: classe = "Suave" elif declividade_perc < 10: classe = "Moderada" elif declividade_perc < 20: classe = "Forte" elif declividade_perc < 45: classe = "Muito forte" else: classe = "Escarpada" st.success(f"‚úÖ **Declividade: {declividade_perc:.2f}%** ({classe})") # Resultados detalhados col1, col2, col3 = st.columns(3) with col1: st.metric("Declividade (%)", f"{declividade_perc:.2f}%") st.metric("Raz√£o", declividade_razao) with col2: st.metric("√Çngulo", f"{angulo_calc:.2f}¬∞") st.metric("Dist. inclinada", f"{dist_inclinada:.2f} m") with col3: st.metric("Classifica√ß√£o", classe) st.metric("Desn√≠vel", f"{desnivel:.2f} m") add_hist_terreno({ "An√°lise": "Declividade", "Dist. horizontal (m)": dist_horizontal, "Desn√≠vel (m)": desnivel, "Declividade (%)": declividade_perc, "√Çngulo (¬∞)": angulo_calc, "Dist. inclinada (m)": dist_inclinada, "Classifica√ß√£o": classe }) # For√ßar atualiza√ß√£o da p√°gina para mostrar hist√≥rico st.rerun() elif analise_tipo.startswith("2"): st.subheader("2) Nivelamento e Cotas") col1, col2, col3 = st.columns(3) with col1: cota_inicial = st.number_input("Cota inicial (m)", value=100.0, step=0.01, format="%.3f") with col2: leitura_re = st.number_input("Leitura de r√© (m)", value=1.500, step=0.001, format="%.3f") with col3: leitura_vante = st.number_input("Leitura de vante (m)", value=2.200, step=0.001, format="%.3f") if st.button("Calcular cota", type="primary", key="btn_nivelamento"): altura_instrumento = cota_inicial + leitura_re cota_final = altura_instrumento - leitura_vante desnivel_total = cota_final - cota_inicial st.success(f"‚úÖ **Cota final: {cota_final:.3f} m** | Desn√≠vel: {desnivel_total:+.3f} m") col1, col2, col3 = st.columns(3) with col1: st.metric("Altura instrumento", f"{altura_instrumento:.3f} m") with col2: st.metric("Cota final", f"{cota_final:.3f} m") with col3: st.metric("Desn√≠vel", f"{desnivel_total:+.3f} m") add_hist_terreno({ "An√°lise": "Nivelamento", "Cota inicial (m)": cota_inicial, "Leitura r√© (m)": leitura_re, "Leitura vante (m)": leitura_vante, "Cota final (m)": cota_final, "Desn√≠vel (m)": desnivel_total }) st.rerun() elif analise_tipo.startswith("3"): st.subheader("3) Volume de Corte/Aterro") col1, col2 = st.columns(2) with col1: area_secao = st.number_input("√Årea da se√ß√£o (m¬≤)", value=10.0, min_value=0.0, step=0.1, format="%.2f") with col2: distancia_secoes = st.number_input("Dist√¢ncia entre se√ß√µes (m)", value=20.0, min_value=0.1, step=1.0, format="%.2f") st.markdown("**M√∫ltiplas se√ß√µes (m√©todo das se√ß√µes m√©dias):**") num_secoes = st.number_input("N√∫mero de se√ß√µes", value=3, min_value=2, max_value=10, step=1) areas_secoes = [] cols = st.columns(min(num_secoes, 5)) for i in range(num_secoes): with cols[i % 5]: area = st.number_input(f"√Årea se√ß√£o {i+1} (m¬≤)", value=area_secao, step=0.1, format="%.2f", key=f"area_{i}") areas_secoes.append(area) if st.button("Calcular volume", type="primary", key="btn_volume"): volume_total = 0 for i in range(len(areas_secoes)-1): volume_trecho = ((areas_secoes[i] + areas_secoes[i+1]) / 2) * distancia_secoes volume_total += volume_trecho st.success(f"‚úÖ **Volume total: {volume_total:.2f} m¬≥** ({volume_total/1000:.3f} milhares de m¬≥)") col1, col2, col3 = st.columns(3) with col1: st.metric("Volume (m¬≥)", f"{volume_total:.2f}") with col2: st.metric("Volume (milhares)", f"{volume_total/1000:.3f}") with col3: st.metric("Se√ß√µes analisadas", f"{len(areas_secoes)}") add_hist_terreno({ "An√°lise": "Volume", "Se√ß√µes": len(areas_secoes), "Dist√¢ncia (m)": distancia_secoes, "Volume (m¬≥)": volume_total, "√Årea m√©dia (m¬≤)": sum(areas_secoes)/len(areas_secoes) }) st.rerun() elif analise_tipo.startswith("4"): st.subheader("4) Dist√¢ncias em Terreno Inclinado") col1, col2 = st.columns(2) with col1: dist_inclinada_terreno = st.number_input("Dist√¢ncia inclinada medida (m)", value=50.0, min_value=0.1, step=0.1, format="%.2f") with col2: angulo_inclinacao = st.number_input("√Çngulo de inclina√ß√£o (¬∞)", value=5.0, step=0.1, format="%.2f") if st.button("Calcular corre√ß√µes", type="primary", key="btn_dist_inclinada"): # Convers√µes angulo_rad = math.radians(angulo_inclinacao) dist_horizontal = dist_inclinada_terreno * math.cos(angulo_rad) desnivel = dist_inclinada_terreno * math.sin(angulo_rad) correcao_horizontal = dist_inclinada_terreno - dist_horizontal st.success(f"‚úÖ **Dist√¢ncia horizontal: {dist_horizontal:.2f} m** | Corre√ß√£o: -{correcao_horizontal:.2f} m") col1, col2, col3 = st.columns(3) with col1: st.metric("Dist. horizontal", f"{dist_horizontal:.2f} m") st.metric("Corre√ß√£o horiz.", f"{correcao_horizontal:.2f} m") with col2: st.metric("Desn√≠vel", f"{desnivel:.2f} m") st.metric("√Çngulo", f"{angulo_inclinacao:.2f}¬∞") with col3: st.metric("Dist. inclinada", f"{dist_inclinada_terreno:.2f} m") st.metric("Erro relativo", f"{(correcao_horizontal/dist_inclinada_terreno)*100:.3f}%") add_hist_terreno({ "An√°lise": "Dist. inclinada", "Dist. inclinada (m)": dist_inclinada_terreno, "√Çngulo (¬∞)": angulo_inclinacao, "Dist. horizontal (m)": dist_horizontal, "Desn√≠vel (m)": desnivel, "Corre√ß√£o (m)": correcao_horizontal }) st.rerun() elif analise_tipo.startswith("5"): st.subheader("5) Coordenadas e Triangula√ß√£o") st.markdown("**C√°lculo de azimute e dist√¢ncia entre dois pontos:**") col1, col2 = st.columns(2) with col1: st.markdown("**Ponto 1 (origem):**") x1 = st.number_input("Coordenada X‚ÇÅ (m ou UTM)", value=500000.0, step=1.0, format="%.2f") y1 = st.number_input("Coordenada Y‚ÇÅ (m ou UTM)", value=7000000.0, step=1.0, format="%.2f") with col2: st.markdown("**Ponto 2 (destino):**") x2 = st.number_input("Coordenada X‚ÇÇ (m ou UTM)", value=500100.0, step=1.0, format="%.2f") y2 = st.number_input("Coordenada Y‚ÇÇ (m ou UTM)", value=7000050.0, step=1.0, format="%.2f") if st.button("Calcular azimute e dist√¢ncia", type="primary", key="btn_coordenadas"): # Diferen√ßas de coordenadas delta_x = x2 - x1 delta_y = y2 - y1 # Dist√¢ncia euclidiana distancia = math.sqrt(delta_x**2 + delta_y**2) # Azimute (√¢ngulo em rela√ß√£o ao norte) if delta_x == 0: azimute_rad = math.pi/2 if delta_y >= 0 else -math.pi/2 else: azimute_rad = math.atan2(delta_x, delta_y) # atan2(E, N) para azimute topogr√°fico azimute_graus = math.degrees(azimute_rad) if azimute_graus < 0: azimute_graus += 360 # Converter para 0-360¬∞ # Rumo (quadrante) abs_delta_x = abs(delta_x) abs_delta_y = abs(delta_y) rumo_rad = math.atan2(abs_delta_x, abs_delta_y) rumo_graus = math.degrees(rumo_rad) # Determinar quadrante if delta_x >= 0 and delta_y >= 0: quadrante = "NE" rumo_completo = f"N {rumo_graus:.2f}¬∞ E" elif delta_x >= 0 and delta_y < 0: quadrante = "SE" rumo_completo = f"S {rumo_graus:.2f}¬∞ E" elif delta_x < 0 and delta_y < 0: quadrante = "SW" rumo_completo = f"S {rumo_graus:.2f}¬∞ W" else: # delta_x < 0 and delta_y >= 0 quadrante = "NW" rumo_completo = f"N {rumo_graus:.2f}¬∞ W" st.success(f"‚úÖ **Dist√¢ncia: {distancia:.2f} m** | **Azimute: {azimute_graus:.2f}¬∞** | **Quadrante: {quadrante}**") col1, col2, col3 = st.columns(3) with col1: st.metric("Dist√¢ncia", f"{distancia:.2f} m") st.metric("ŒîX (E)", f"{delta_x:+.2f} m") with col2: st.metric("Azimute", f"{azimute_graus:.2f}¬∞") st.metric("ŒîY (N)", f"{delta_y:+.2f} m") with col3: st.metric("Rumo", rumo_completo) st.metric("Quadrante", quadrante) add_hist_terreno({ "An√°lise": "Coordenadas", "X‚ÇÅ": x1, "Y‚ÇÅ": y1, "X‚ÇÇ": x2, "Y‚ÇÇ": y2, "Dist√¢ncia (m)": distancia, "Azimute (¬∞)": azimute_graus, "Quadrante": quadrante }) st.rerun() st.markdown("---") st.subheader("üßæ Hist√≥rico (An√°lise de Terreno)") if len(st.session_state.historico_terreno) == 0: st.info("Sem an√°lises ainda. Execute uma an√°lise para registrar no hist√≥rico.") else: df3 = pd.DataFrame(st.session_state.historico_terreno) st.dataframe(df3, width="stretch") # Bot√£o de limpeza col1, col2 = st.columns([3, 1]) with col2: if st.button("üóëÔ∏è Limpar hist√≥rico", key="clear_terreno"): st.session_state.historico_terreno = [] st.rerun() # Download buffer3 = io.BytesIO() with pd.ExcelWriter(buffer3, engine="openpyxl") as writer: df3.to_excel(writer, sheet_name="Historico_Terreno", index=False) st.download_button( label="‚¨áÔ∏è Baixar hist√≥rico (Terreno) em XLSX", data=buffer3.getvalue(), file_name="historico_analise_terreno.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", key="dl_hist_terreno" ) # ======================================== # === ABA 3: CATEN√ÅRIA AVAN√áADA ========= # ======================================== with tabs[2]: st.markdown("ü™¢ **Calculadora de Caten√°ria Avan√ßada**") st.markdown( """ **Modelo matem√°tico exato de caten√°ria** para an√°lise rigorosa de cabos suspensos: **O que voc√™ precisa informar:** - **Geometria:** L (v√£o em m), **altura dos pontos de fixa√ß√£o** √† esquerda e direita **acima do solo local** (H_esq, H_dir), e **desn√≠vel do solo** entre os apoios Œîh_solo (m) ‚Äî positivo se o solo √† direita √© mais alto. - **Cabo e carregamentos:** **peso linear vertical** w (kg/m ou N/m) e, se quiser, **componente de vento** p_v (N/m). - **Modo de c√°lculo:** 1) **Por Tens√£o Horizontal H** (N ou kN); 2) **Por Flecha no meio** (m); 3) **Por Comprimento do cabo** entre os apoios (m). > A sa√≠da traz **flecha (vs corda)**, **folga m√≠nima ao solo**, **posi√ß√£o da folga m√≠nima**, e **tra√ß√£o** em cada apoio. """ ) st.markdown("---") # ----- Entradas comuns ----- L_cat = st.number_input("L (m) ‚Äî v√£o entre apoios", value=60.0, min_value=1.0, step=1.0, format="%.2f", key="L_catenaria") colh1_cat, colh2_cat = st.columns(2) with colh1_cat: H_esq_cat = st.number_input("H_esq (m) ‚Äî altura do ponto de fixa√ß√£o ESQ acima do solo local", value=12.0, min_value=0.0, step=0.1, format="%.2f", key="H_esq_cat") with colh2_cat: H_dir_cat = st.number_input("H_dir (m) ‚Äî altura do ponto de fixa√ß√£o DIR acima do solo local", value=12.0, min_value=0.0, step=0.1, format="%.2f", key="H_dir_cat") desnivel_cat = st.checkbox("Considerar desn√≠vel do solo entre apoios?", value=False, key="desnivel_cat") delta_solo_cat = 0.0 if desnivel_cat: delta_solo_cat = st.number_input("Œîh_solo (m) ‚Äî solo(DIR) ‚àí solo(ESQ)", value=0.0, step=0.1, format="%.2f", key="delta_solo_cat") st.markdown("### üìã Sele√ß√£o de Cabo e Carregamentos") # Sele√ß√£o autom√°tica de cabo do cat√°logo nome_cabo, peso_kgpm = selector_cabo(prefix="cat_") # Exibir informa√ß√µes do cabo selecionado col_cabo1, col_cabo2 = st.columns(2) with col_cabo1: st.success(f"**Cabo selecionado:** {nome_cabo}") with col_cabo2: st.metric("Peso linear", f"{peso_kgpm:.3f} kg/m", f"{peso_kgpm * 9.80665:.1f} N/m") # Ajuste t√©rmico opcional ajuste_termico = st.checkbox("üå°Ô∏è Aplicar ajuste t√©rmico no peso?", value=False, key="ajuste_termico_cat", help="Compensa√ß√£o t√©rmica pode afetar as propriedades do cabo") fator_termico = 1.0 if ajuste_termico: col_t1, col_t2 = st.columns(2) with col_t1: temp_ref = st.number_input("Temp. refer√™ncia (¬∞C)", value=20.0, step=1.0, format="%.1f", key="temp_ref_cat") with col_t2: temp_atual = st.number_input("Temp. atual (¬∞C)", value=30.0, step=1.0, format="%.1f", key="temp_atual_cat") # Fator t√©rmico simplificado (pode ser expandido com coeficientes espec√≠ficos do cabo) delta_temp = temp_atual - temp_ref fator_termico = 1.0 + (delta_temp * 0.001) # Aproxima√ß√£o simples: ~0.1% por ¬∞C st.info(f"Fator t√©rmico: {fator_termico:.4f} (Œît = {delta_temp:+.1f}¬∞C)") # Peso efetivo com ajuste t√©rmico peso_ajustado_kgm = peso_kgpm * fator_termico # Componente de vento colv1, colv2 = st.columns(2) with colv1: vento_on_cat = st.checkbox("üí® Adicionar componente de vento (N/m)?", value=False, key="vento_on_cat") with colv2: p_vento_cat = 0.0 if vento_on_cat: # Verificar se h√° um valor calculado pendente para aplicar apply_key = "calc_apply_pv_flag" default_value = st.session_state.get(apply_key, 0.0) if apply_key in st.session_state: # Limpar o valor aplicado ap√≥s usar del st.session_state[apply_key] p_vento_cat = st.number_input("p_v (N/m) ‚Äî componente lateral equivalente", value=default_value, min_value=0.0, step=1.0, format="%.1f", help="Se n√£o souber, use o calculador de p_v abaixo.", key="calc_pv") # Mini-calculador de vento (quando habilitado) if vento_on_cat: vento_calc_expander(prefix="calc_", nome_cabo=nome_cabo, target_key="calc_pv") # Dicas t√©cnicas detalhadas with st.expander("üìã Dicas t√©cnicas para preenchimento correto"): st.markdown(""" **1) V (m/s) ‚Äì velocidade do vento de projeto** **Fonte "correta":** NBR 6123 ‚Üí pegue o V‚ÇÄ do mapa de ventos para sua cidade e aplique os fatores S1 (topografia), S2 (rugosidade/altura) e S3 (import√¢ncia). Resultado: V_site = V‚ÇÄ¬∑S1¬∑S2¬∑S3. **Pr√°tico quando n√£o tiver a planilha:** use um cen√°rio conservador para distribui√ß√£o (ex.: 35 m/s; para verifica√ß√£o severa, 40 m/s). Se a Energisa tiver valor corporativo, use-o. **2) D_eq (mm) ‚Äì di√¢metro/largura equivalente do cabo** Pegue direto do cat√°logo do cabo que voc√™ selecionou no app: - **MT coberto (XLPE)** ‚Äì o cat√°logo traz "Di√¢metro externo (mm)" por se√ß√£o. Exemplos: - 15 kV: 70 mm¬≤ ‚Üí 17,80 mm; 95 mm¬≤ ‚Üí 19,60 mm; 150 mm¬≤ ‚Üí 22,30 mm - 25 kV: 120 mm¬≤ ‚Üí 29,20 mm; 150 mm¬≤ ‚Üí 30,50 mm; 185 mm¬≤ ‚Üí 31,40 mm - **CAA/ACSR (nu)** ‚Äì use o di√¢metro do cabo: por exemplo 3/0 ACSR ‚Üí 12,74 mm e 4/0 ACSR ‚Üí 14,31 mm; tamb√©m h√° op√ß√µes em mm¬≤ (ex.: 95 mm¬≤ ‚Üí 12,50 mm) - **BT multiplexado (ABC)** ‚Äì use a coluna "Di√¢metro Reunido (mm)" (√© a "largura de frente" do feixe) da tabela de Multiplexados **Dica:** se tiver gelo, use D_eq = D_externo + 2¬∑t_gelo. **3) C_d ‚Äì coeficiente de arrasto (sem ensaio)** - **Cabo cil√≠ndrico simples (CAA/MT coberto):** C_d ‚âà 1,20 (padr√£o de projeto) - **Feixe ABC:** C_d ‚âà 1,30 (mais conservador) - **Com gelo/forma √°spera:** 1,40‚Äì1,60 (use se for caso cr√≠tico) """) # Converter peso para N/m w_vert_Npm = peso_ajustado_kgm * 9.80665 st.markdown("### üõ°Ô∏è Verifica√ß√£o de Folga M√≠nima") # Sele√ß√£o de classe de folga folga_requerida, meta_folga = folga_norma_selector(prefix="cat_") # Exibir informa√ß√µes da folga selecionada col_folga1, col_folga2 = st.columns(2) with col_folga1: perfil_info = f"**{meta_folga['perfil']}:** {meta_folga['tipo']}" st.info(perfil_info) with col_folga2: st.metric("Folga m√≠nima requerida", f"{folga_requerida:.2f} m") st.markdown("### ‚öôÔ∏è Escolha o modo de c√°lculo") modo_cat = st.radio("Modo", options=["1) Por Tens√£o Horizontal (H)", "2) Por Flecha no meio (f)", "3) Por Comprimento do cabo (S)"], horizontal=True, key="modo_cat") try: if modo_cat.startswith("1"): colH1_cat, colH2_cat = st.columns(2) with colH1_cat: H_unit_cat = st.selectbox("Unidade de H (tens√£o horizontal)", ["kN", "N"], index=0, key="H_unit_cat") with colH2_cat: H_in_cat = st.number_input(f"H ({H_unit_cat})", value=2.5, min_value=0.0, step=0.1, format="%.3f", key="H_in_cat") H_horiz_N = H_in_cat*1000.0 if H_unit_cat == "kN" else H_in_cat if st.button("Calcular caten√°ria", type="primary", key="btn_cat_H"): res = compute_catenary_from_H( L=L_cat, H_left=H_esq_cat, H_right=H_dir_cat, delta_solo=delta_solo_cat, w_vert_Npm=w_vert_Npm, p_wind_Npm=p_vento_cat, H_horiz_N=H_horiz_N ) st.success( f"‚úÖ **Flecha no meio (vs corda): {res['sag_meio (m)']:.2f} m** | " f"**Flecha m√°x: {res['sag_max (m)']:.2f} m** em x={res['x_sag_max (m)']:.2f} m | " f"**Folga m√≠nima ao solo: {res['clear_min (m)']:.2f} m** em x={res['x_clear_min (m)']:.2f} m" ) st.info( f"Tens√£o horizontal H = {res['H_horizontal (N)']:.0f} N | " f"T_esq = {res['T_left (N)']:.0f} N | T_dir = {res['T_right (N)']:.0f} N" ) # Verifica√ß√£o de folga de seguran√ßa show_ok_alerta(clear_min=res['clear_min (m)'], folga_req=folga_requerida) df = res["curve"] fig = pretty_catenary_plot( df=df, L=L_cat, H_esq=H_esq_cat, H_dir=H_dir_cat, delta_solo=delta_solo_cat, res=res, folga_req=folga_requerida, titulo="Caten√°ria ‚Äî Modo H" ) st.pyplot(fig, use_container_width=True, dpi=160) # ‚Äî montar contexto-base para o relat√≥rio ‚Äî contexto_base = { "L": L_cat, "H_esq": H_esq_cat, "H_dir": H_dir_cat, "delta_solo": delta_solo_cat, "cabo_nome": nome_cabo, "w_kgpm": peso_ajustado_kgm, "w_Npm": w_vert_Npm, "p_vento": p_vento_cat, "folga_req": folga_requerida, "criterio": "NBR 15992", "metodo_descr": f"Por Tens√£o Horizontal H = {res['H_horizontal (N)']/1000:.3f} kN", "obra": "", "cliente": "", "engenheiro": "", "crea": "", "obs": "" } # ‚Äî bloco de relat√≥rio PDF ‚Äî pdf_expander_ui(res, df, fig, contexto_base) # ‚Äî bloco de relat√≥rio Word ‚Äî word_expander_ui(res, df, fig, contexto_base) # ‚Äî utilidades de montagem ‚Äî S_val = catenary_length_from_params(L_cat, res["a (m)"], res["xc (m)"]) slack = S_val - L_cat st.info(f"Comprimento do cabo **S ‚âà {S_val:.3f} m** | S‚àíL = {slack:.3f} m ({(slack/L_cat)*100:.2f}%)") copy_s_and_bobina_ui(S_val, prefix="H_") # Download XLSX buff = io.BytesIO() with pd.ExcelWriter(buff, engine="openpyxl") as wr: df.to_excel(wr, index=False, sheet_name="Perfil") pd.DataFrame([{ "a (m)": res["a (m)"], "xc (m)": res["xc (m)"], "yc (m)": res["yc (m)"], "w_eff (N/m)": res["w_eff (N/m)"], "H (N)": res["H_horizontal (N)"], "T_esq (N)": res["T_left (N)"], "T_dir (N)": res["T_right (N)"], "sag_meio (m)": res["sag_meio (m)"], "sag_max (m)": res["sag_max (m)"], "x_sag_max (m)": res["x_sag_max (m)"], "clear_min (m)": res["clear_min (m)"], "x_clear_min (m)": res["x_clear_min (m)"] }]).to_excel(wr, index=False, sheet_name="Resumo") st.download_button("‚¨áÔ∏è Baixar XLSX (perfil + resumo)", buff.getvalue(), "catenaria_resultados.xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", key="dl_cat_H") elif modo_cat.startswith("2"): f_mid_cat = st.number_input("f (m) ‚Äî flecha no meio (em rela√ß√£o √† corda)", value=1.50, min_value=0.0, step=0.1, format="%.2f", key="f_mid_cat") if st.button("Calcular caten√°ria", type="primary", key="btn_cat_f"): res = compute_catenary_from_mid_sag( L=L_cat, H_left=H_esq_cat, H_right=H_dir_cat, delta_solo=delta_solo_cat, w_vert_Npm=w_vert_Npm, p_wind_Npm=p_vento_cat, sag_mid_target=f_mid_cat ) st.success( f"‚úÖ **Flecha no meio (vs corda): {res['sag_meio (m)']:.2f} m** | " f"**Flecha m√°x: {res['sag_max (m)']:.2f} m** em x={res['x_sag_max (m)']:.2f} m | " f"**Folga m√≠nima ao solo: {res['clear_min (m)']:.2f} m** em x={res['x_clear_min (m)']:.2f} m" ) st.info( f"Tens√£o horizontal estimada H = {res['H_horizontal (N)']:.0f} N | " f"T_esq = {res['T_left (N)']:.0f} N | T_dir = {res['T_right (N)']:.0f} N" ) # Verifica√ß√£o de folga de seguran√ßa show_ok_alerta(clear_min=res['clear_min (m)'], folga_req=folga_requerida) df = res["curve"] fig = pretty_catenary_plot( df=df, L=L_cat, H_esq=H_esq_cat, H_dir=H_dir_cat, delta_solo=delta_solo_cat, res=res, folga_req=folga_requerida, titulo="Caten√°ria ‚Äî Modo f" ) st.pyplot(fig, use_container_width=True, dpi=160) # ‚Äî montar contexto-base para o relat√≥rio ‚Äî contexto_base = { "L": L_cat, "H_esq": H_esq_cat, "H_dir": H_dir_cat, "delta_solo": delta_solo_cat, "cabo_nome": nome_cabo, "w_kgpm": peso_ajustado_kgm, "w_Npm": w_vert_Npm, "p_vento": p_vento_cat, "folga_req": folga_requerida, "criterio": "NBR 15992", "metodo_descr": f"Por Flecha no meio (alvo) = {f_mid_cat:.2f} m", "obra": "", "cliente": "", "engenheiro": "", "crea": "", "obs": "" } # ‚Äî bloco de relat√≥rio PDF ‚Äî pdf_expander_ui(res, df, fig, contexto_base) # ‚Äî bloco de relat√≥rio Word ‚Äî word_expander_ui(res, df, fig, contexto_base) # ‚Äî utilidades de montagem ‚Äî S_val = catenary_length_from_params(L_cat, res["a (m)"], res["xc (m)"]) slack = S_val - L_cat st.info(f"Comprimento do cabo **S ‚âà {S_val:.3f} m** | S‚àíL = {slack:.3f} m ({(slack/L_cat)*100:.2f}%)") copy_s_and_bobina_ui(S_val, prefix="F_") buff = io.BytesIO() with pd.ExcelWriter(buff, engine="openpyxl") as wr: df.to_excel(wr, index=False, sheet_name="Perfil") pd.DataFrame([{ "a (m)": res["a (m)"], "xc (m)": res["xc (m)"], "yc (m)": res["yc (m)"], "w_eff (N/m)": res["w_eff (N/m)"], "H (N)": res["H_horizontal (N)"], "T_esq (N)": res["T_left (N)"], "T_dir (N)": res["T_right (N)"], "sag_meio (m)": res["sag_meio (m)"], "sag_max (m)": res["sag_max (m)"], "x_sag_max (m)": res["x_sag_max (m)"], "clear_min (m)": res["clear_min (m)"], "x_clear_min (m)": res["x_clear_min (m)"] }]).to_excel(wr, index=False, sheet_name="Resumo") st.download_button("‚¨áÔ∏è Baixar XLSX (perfil + resumo)", buff.getvalue(), "catenaria_resultados.xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", key="dl_cat_f") else: S_cat = st.number_input("S (m) ‚Äî comprimento do cabo entre apoios", value=61.2, min_value=L_cat+1e-6, step=0.1, format="%.3f", help="Deve ser > L.", key="S_cat") if st.button("Calcular caten√°ria", type="primary", key="btn_cat_S"): res = compute_catenary_from_length( L=L_cat, H_left=H_esq_cat, H_right=H_dir_cat, delta_solo=delta_solo_cat, w_vert_Npm=w_vert_Npm, p_wind_Npm=p_vento_cat, cable_length=S_cat ) st.success( f"‚úÖ **Flecha no meio (vs corda): {res['sag_meio (m)']:.2f} m** | " f"**Flecha m√°x: {res['sag_max (m)']:.2f} m** em x={res['x_sag_max (m)']:.2f} m | " f"**Folga m√≠nima ao solo: {res['clear_min (m)']:.2f} m** em x={res['x_clear_min (m)']:.2f} m" ) st.info( f"Tens√£o horizontal H = {res['H_horizontal (N)']:.0f} N | " f"T_esq = {res['T_left (N)']:.0f} N | T_dir = {res['T_right (N)']:.0f} N" ) # Verifica√ß√£o de folga de seguran√ßa show_ok_alerta(clear_min=res['clear_min (m)'], folga_req=folga_requerida) df = res["curve"] fig = pretty_catenary_plot( df=df, L=L_cat, H_esq=H_esq_cat, H_dir=H_dir_cat, delta_solo=delta_solo_cat, res=res, folga_req=folga_requerida, titulo="Caten√°ria ‚Äî Modo S" ) st.pyplot(fig, use_container_width=True, dpi=160) # ‚Äî montar contexto-base para o relat√≥rio ‚Äî contexto_base = { "L": L_cat, "H_esq": H_esq_cat, "H_dir": H_dir_cat, "delta_solo": delta_solo_cat, "cabo_nome": nome_cabo, "w_kgpm": peso_ajustado_kgm, "w_Npm": w_vert_Npm, "p_vento": p_vento_cat, "folga_req": folga_requerida, "criterio": "NBR 15992", "metodo_descr": f"Por Comprimento do cabo S = {S_cat:.2f} m", "obra": "", "cliente": "", "engenheiro": "", "crea": "", "obs": "" } # ‚Äî bloco de relat√≥rio PDF ‚Äî pdf_expander_ui(res, df, fig, contexto_base) # ‚Äî bloco de relat√≥rio Word ‚Äî word_expander_ui(res, df, fig, contexto_base) # ‚Äî utilidades de montagem ‚Äî S_val = catenary_length_from_params(L_cat, res["a (m)"], res["xc (m)"]) st.caption(f"Checagem: S informado = {S_cat:.3f} m | S calculado = {S_val:.3f} m | Œî = {S_val - S_cat:+.3f} m") copy_s_and_bobina_ui(S_val, prefix="S_") buff = io.BytesIO() with pd.ExcelWriter(buff, engine="openpyxl") as wr: df.to_excel(wr, index=False, sheet_name="Perfil") pd.DataFrame([{ "a (m)": res["a (m)"], "xc (m)": res["xc (m)"], "yc (m)": res["yc (m)"], "w_eff (N/m)": res["w_eff (N/m)"], "H (N)": res["H_horizontal (N)"], "T_esq (N)": res["T_left (N)"], "T_dir (N)": res["T_right (N)"], "sag_meio (m)": res["sag_meio (m)"], "sag_max (m)": res["sag_max (m)"], "x_sag_max (m)": res["x_sag_max (m)"], "clear_min (m)": res["clear_min (m)"], "x_clear_min (m)": res["x_clear_min (m)"] }]).to_excel(wr, index=False, sheet_name="Resumo") st.download_button("‚¨áÔ∏è Baixar XLSX (perfil + resumo)", buff.getvalue(), "catenaria_resultados.xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", key="dl_cat_S") except Exception as e: st.error(f"Erro no c√°lculo: {e}") st.markdown("---") # === Informa√ß√µes adicionais === st.subheader("üìö Informa√ß√µes T√©cnicas") col_info1, col_info2 = st.columns(2) with col_info1: st.markdown("### üßÆ **Modelo Matem√°tico**") st.info(""" **Caten√°ria exata** com par√¢metros f√≠sicos reais: - **Peso efetivo**: w_eff = ‚àö(w_vert¬≤ + p_vento¬≤) - **Par√¢metro**: a = H / w_eff - **Equa√ß√£o**: y = yc + a¬∑cosh((x-xc)/a) **Solu√ß√µes num√©ricas** para apoios desnivelados e comprimento de cabo. """) with col_info2: st.markdown("### üõ°Ô∏è **Verifica√ß√£o de Seguran√ßa**") st.info(""" **Folga autom√°tica** baseada na classe de uso: - üö∂ **Pedestres**: 5.5 m - üèòÔ∏è **Rua local**: 6.0 m - üõ£Ô∏è **Rodovia**: 7.0 m - üöõ **Acesso veicular**: 5.5 m **Status visual**: OK üü¢ / ALERTA üü† """) st.markdown("### üí° **Recursos Avan√ßados**") col_rec1, col_rec2, col_rec3 = st.columns(3) with col_rec1: st.markdown("**üîß Cat√°logo Integrado**") st.caption("‚Ä¢ Cabos BT/MT padronizados\n‚Ä¢ Pesos autom√°ticos por se√ß√£o\n‚Ä¢ CAA, XLPE, Multiplexado") with col_rec2: st.markdown("**üå°Ô∏è Compensa√ß√£o T√©rmica**") st.caption("‚Ä¢ Ajuste por temperatura\n‚Ä¢ Fator ~0.1% por ¬∞C\n‚Ä¢ Efeito no peso linear") with col_rec3: st.markdown("**üí® Carregamento de Vento**") st.caption("‚Ä¢ Componente lateral\n‚Ä¢ Peso efetivo resultante\n‚Ä¢ p_v ‚âà q √ó Cd √ó D") st.markdown("---") st.caption("üéØ **Modelo de caten√°ria exata** com verifica√ß√£o autom√°tica de seguran√ßa. Para estudos avan√ßados de temperatura, m√≥dulo el√°stico e flu√™ncia, considere ferramentas especializadas como PLS-CADD.") # ======================================= # ======== ABA 4: SEGURAN√áA EL√âTRICA === # ======================================= with tabs[3]: st.header("‚ö° Verifica√ß√£o de Seguran√ßa El√©trica - NBR 15992") st.markdown(""" **Verifica√ß√£o de dist√¢ncias m√≠nimas de seguran√ßa** para trabalhos pr√≥ximos a redes el√©tricas, conforme **NBR 15992 - Tabela 13**. üö® **ATEN√á√ÉO**: Esta ferramenta √© para orienta√ß√£o t√©cnica. **Sempre consulte profissionais qualificados** e siga os procedimentos oficiais de seguran√ßa da sua empresa. """) # === Configura√ß√£o da verifica√ß√£o === st.subheader("üìã Configura√ß√£o da Verifica√ß√£o") col_segur1, col_segur2 = st.columns(2) with col_segur1: tensao_kv = st.selectbox( "‚ö° Tens√£o da rede el√©trica (kV)", [69, 138, 230, 345, 500], index=0, help="Tens√£o nominal da linha el√©trica em kV" ) # Lista de tipos de locais/obst√°culos tipos_locais = list(NBR15992_T13.keys()) tipo_local = st.selectbox( "üèóÔ∏è Tipo de local/obst√°culo", tipos_locais, index=0, help="Selecione o tipo de local ou obst√°culo conforme NBR 15992" ) with col_segur2: distancia_medida = st.number_input( "üìè Dist√¢ncia medida (m)", value=10.0, min_value=0.0, step=0.1, format="%.2f", help="Dist√¢ncia horizontal entre o ponto de trabalho e a estrutura energizada" ) # Campo altura para tipos H+ (dependentes de altura) altura_obstaculo = None if "H+" in NBR15992_T13[tipo_local]: altura_obstaculo = st.number_input( "üìê Altura do obst√°culo (m)", value=12.0, min_value=0.0, step=0.1, format="%.2f", help="Altura do obst√°culo para c√°lculo H+ (necess√°rio para este tipo de local)" ) # === Verifica√ß√£o de seguran√ßa === if st.button("üîç Verificar Seguran√ßa El√©trica", type="primary"): resultado = verificar_seguranca_eletrica( distancia_medida=distancia_medida, tipo_local=tipo_local, tensao_kv=tensao_kv, altura_obstaculo=altura_obstaculo ) if resultado["seguro"] is None: st.error(f"‚ùå **Erro**: {resultado['descricao']}") elif resultado["seguro"]: st.success(f"‚úÖ **SEGURO** - Dist√¢ncia adequada!") st.info(f"üìè **Dist√¢ncia m√≠nima NBR 15992**: {resultado['distancia_minima']:.1f} m") st.info(f"üîí **Margem de seguran√ßa**: +{resultado['diferenca']:.1f} m") st.info(f"‚ö° **Tens√£o**: {resultado['tensao_kv']} kV | **C√°lculo**: {resultado['descricao']}") else: st.error(f"üö® **PERIGO** - Dist√¢ncia insuficiente!") st.error(f"üìè **Dist√¢ncia m√≠nima NBR 15992**: {resultado['distancia_minima']:.1f} m") st.error(f"‚ö†Ô∏è **D√©ficit de seguran√ßa**: {abs(resultado['diferenca']):.1f} m") st.error(f"‚ö° **Tens√£o**: {resultado['tensao_kv']} kV | **C√°lculo**: {resultado['descricao']}") # Recomenda√ß√µes de seguran√ßa st.markdown("### üõ°Ô∏è **Recomenda√ß√µes de Seguran√ßa**") st.warning(f"üîí **Manter dist√¢ncia m√≠nima de {resultado['distancia_minima']:.1f} m**") st.warning("‚ö° **Desenergizar a linha se poss√≠vel**") st.warning("üë• **Usar EPI adequado e seguir procedimentos da empresa**") st.warning("üìû **Contatar supervisor respons√°vel**") # === Tabela de refer√™ncia NBR 15992 === st.markdown("---") st.subheader("üìö Tabela de Refer√™ncia NBR 15992") # Criar tabela de refer√™ncia para visualiza√ß√£o ref_data = [] for local, valores in NBR15992_T13.items(): if "H+" in valores: # Tipo altura dependente h_base = valores["H+"] exemplo_h = 12.0 # altura exemplo row = {"Tipo de Local/Obst√°culo": local, "Tipo": "H+ (altura dependente)"} for kv in [69, 138, 230, 345, 500]: dist_exemplo = exemplo_h + h_base[kv] row[f"{kv} kV"] = f"H+{h_base[kv]:.1f}m (ex: {dist_exemplo:.1f}m)" ref_data.append(row) else: # Tipo fixo row = {"Tipo de Local/Obst√°culo": local, "Tipo": "Fixo"} for kv in [69, 138, 230, 345, 500]: row[f"{kv} kV"] = f"{valores[kv]:.1f}m" ref_data.append(row) df_ref = pd.DataFrame(ref_data) st.dataframe(df_ref, width="stretch") # === Notas importantes === st.markdown("### üìù **Notas Importantes**") st.info(""" **üîç Tipos de dist√¢ncia**: - **Fixo**: Dist√¢ncia constante independente da altura - **H+**: Altura do obst√°culo + dist√¢ncia adicional da tabela **‚ö° Tens√µes dispon√≠veis**: 69, 138, 230, 345, 500 kV **üèóÔ∏è Exemplos de aplica√ß√£o**: - Instala√ß√£o de estruturas pr√≥ximas a LT - Trabalhos com m√°quinas agr√≠colas - Constru√ß√£o em √°reas com redes el√©tricas - Planejamento de dist√¢ncias de seguran√ßa """) st.warning(""" üö® **IMPORTANTE**: Esta ferramenta √© apenas para **orienta√ß√£o t√©cnica**. **Sempre**: - Consulte profissionais qualificados (engenheiros eletricistas) - Siga normas e procedimentos da sua empresa - Use EPI adequado - Coordene com a concession√°ria de energia """) # === Hist√≥rico de verifica√ß√µes === st.markdown("---") st.subheader("üìä Hist√≥rico de Verifica√ß√µes de Seguran√ßa") # Inicializar hist√≥rico no session state if "historico_seguranca" not in st.session_state: st.session_state.historico_seguranca = [] # Adicionar ao hist√≥rico quando calculado if st.button("üíæ Salvar verifica√ß√£o no hist√≥rico"): if len(st.session_state.historico_seguranca) == 0 or distancia_medida > 0: # Fazer verifica√ß√£o novamente para salvar resultado = verificar_seguranca_eletrica( distancia_medida=distancia_medida, tipo_local=tipo_local, tensao_kv=tensao_kv, altura_obstaculo=altura_obstaculo ) if resultado["seguro"] is not None: registro = { "Data/Hora": pd.Timestamp.now().strftime("%d/%m/%Y %H:%M"), "Local/Obst√°culo": tipo_local, "Tens√£o (kV)": tensao_kv, "Dist. Medida (m)": distancia_medida, "Dist. M√≠n NBR (m)": resultado["distancia_minima"], "Status": "‚úÖ SEGURO" if resultado["seguro"] else "üö® PERIGO", "Diferen√ßa (m)": round(resultado["diferenca"], 2), "Altura (m)": altura_obstaculo if altura_obstaculo else "-" } st.session_state.historico_seguranca.append(registro) st.success("üíæ Verifica√ß√£o salva no hist√≥rico!") # Exibir hist√≥rico se existir if len(st.session_state.historico_seguranca) > 0: df_hist = pd.DataFrame(st.session_state.historico_seguranca) st.dataframe(df_hist, width="stretch") # Download do hist√≥rico try: buffer_seg = io.BytesIO() with pd.ExcelWriter(buffer_seg, engine="openpyxl") as writer: df_hist.to_excel(writer, sheet_name="Historico_Seguranca", index=False) st.download_button( label="‚¨áÔ∏è Baixar hist√≥rico de seguran√ßa (XLSX)", data=buffer_seg.getvalue(), file_name="historico_seguranca_eletrica_NBR15992.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" ) except ImportError: # Fallback para CSV csv_seg = df_hist.to_csv(index=False) st.download_button( label="‚¨áÔ∏è Baixar hist√≥rico de seguran√ßa (CSV)", data=csv_seg, file_name="historico_seguranca_eletrica_NBR15992.csv", mime="text/csv" ) st.markdown("---") st.caption( "Dicas: mire em superf√≠cies s√≥lidas (cruzeta/isolador/placa), fa√ßa 3 leituras e use a m√©dia. " "Mantenha dist√¢ncia de seguran√ßa e evite medi√ß√µes sob tempestade." )
